<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跳出舒适区-入坑Ubuntu折腾记]]></title>
    <url>%2F2017%2F11%2F20%2F%E8%B7%B3%E5%87%BA%E8%88%92%E9%80%82%E5%8C%BA-%E5%85%A5%E5%9D%91Ubuntu%E6%8A%98%E8%85%BE%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近朋友打算把windows换成了linux当做主力系统来用，自己也一时心血来潮，折腾了几天，多次重装配置后终于把ubuntu折腾成合心意的样子。其实这并不是我第一次装Ubuntu，大概一年前左右也抱着一个想学习linux的伟大理想，在电脑里装了双系统，只可惜那时候对linux的认识近乎为0，装完了没几天因为难操作就再也没有碰过了，久而久之也就顺手删掉了装有Ubuntu的磁盘分区，放下了执念。后来对linux的学习，就停留在鸟哥的书中以及虚拟机里，以及一些云服务器的远程操作。由于近来在刷实验楼（在线编程网站），在实验环境中熟悉了一把linux操作，再加上对linux已经有了一定的了解，在朋友的刺激下，就重新开始了折腾，不过这次是认真的。 下载与安装关于下载和安装步骤，随便在网络上搜一下就能出很多的教程，由于经常性的装系统，基本不需要参考，娴熟地直接去官网下载Ubuntu镜像和制作好U盘启动盘后，了解下Linux分区注意事项后就顺利的装上了Ubuntu16.04LTS版本。具体过程就不过多记录了，不过对于Linux的文件系统、目录结构、磁盘分区等相关概念，还是需要留点心思的，因为在安装过程中可以自行创建分区,并且指定分区挂载在哪个目录上,了解这方面有助于做好这一步的决策。 Linux虚拟文件系统 好文推荐阅读比起Windows，怎样解读Linux的文件系统与目录结构？ 文件系统,解决的是文件在硬盘中的管理问题,还没学linux之前,我所理解的文件就仅限于文档,图片,视频,还有软件数据文件和系统文件等等一切可以在CDEF盘中看到的东西,处于先有硬盘然后分区格式化产生文件系统最后才能管理文件的回路中,而linux则刷新了认知,一切皆文件,甚至在windows概念中统治着文件的磁盘以及其他奇奇怪怪的东西，都只是linux的一个文件而已。这种一切皆文件逻辑的实现，依赖于虚拟文件系统的设计。在linux系统启动过程，内存会先加载具备文件管理，设备管理，内存管理，CPU进程调度管理，网络管理等功能的linux内核，然后内核在内存中建立虚拟文件系统，也就是以/根目录开始的目录树，进而挂载各种资源（硬盘，键盘，鼠标，数据，程序，CPU，内存，网卡等）到特定目录中，以文件的方式进行管理。不得不说Linus真的强，让linux内核仅仅保留管理软硬件资源的能力，其他则让我们在虚拟文件系统上自由发挥，为所欲为。在虚拟文件系统之下，还延伸出一套定义linux操作系统主要目录及目录内容的标准——文件系统层次结构标准（英语：Filesystem Hierarchy Standard，FHS） FHS-文件系统层次结构标准 维基百科 FHS是随着时间和使用经验不断发展的，在日后可能也还会不断修改，因为linux是一个允许多用户同时操作的系统，不像windows（我们在操作别人电脑时是不是经常由于不熟悉，不知道文件放在哪里而花费时间在找文件上）。在linux中，只要大家都遵循FHS，大家对同一台主机就会有一个共识，知道哪些文件能碰，哪些不能碰，甚至面对所有linux主机都能很快上手工作，而问题更多的出现在用户权限上。所以FHS标准是一个解决多用户使用系统时相互干涉问题很好的手段。 目录与分区策略在了解各目录之后，就可以根据用途设置相应的分区策略了。详细可参考linux分区方案 一些完成安装后的设置(收集整理)系统设置 让Ubuntu使用本地时区，修复双系统时间显示不一致 timedatectl set-local-rtc 1 显卡驱动设置：系统设置&gt;软件和更新&gt;附加驱动&gt;使用nvdia专有驱动 更换软件源 软件源告诉系统获取软件的位置,除了Ubuntu官方软件源及国内镜像外，还有PPA独立开发者软件源软件源地址及更换方式详解Ubuntu软件源 桌面美化更换为gnome 安装gnome-shell的时候选择lightgm，不然开机默认还是unitysudo apt-get install gnome-shellsudo apt-get install ubuntu-gnome-desktop 一开始使用自带unity桌面，时不时卡顿，后来更换gnome桌面几乎没有卡顿现象,而且特别喜欢，然后就顺手删掉了unity桌面 主题和图标 安装Flatabulous主题 sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme Flatabulous主题的配套图标 sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 安装gnome-tweak-tool，设置主题和图标 sudo apt-get install gnome-tweak-tool Docky，类似mac的dock栏 sudo add-apt-repository ppa:docky-core/stablesudo apt-get updatesudo apt-get install docky 软件管理必须清楚，linux有众多发行版，例如redhad、debian等等派别，在软件包管理上有着不同的方式，ubuntu属于使用apt包管理的debian系。在尝试过想要删除源码安装的软件由于无法执行make uninstall后需要根据安装日志删除不同位置的文件时，我就彻底决定能用apt或dpkg管理软件则优先使用这些工具了。 删除自带软件 删除软件及配置文件：sudo apt-get remove –purge thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install onboard deja-dup libreoffice* unity-webapps-common清除依赖：sudo apt-get autoremove thunderbird 邮件客户端 totem 电影播放器 rhythmbox 音乐播放器 empathy 聊天软件 brasero 光盘刻录工具 simple-scan 扫描器 gnome-mahjongg 对对碰游戏 aisleriot 纸牌 gnome-mines 扫雷 cheese 相机 transmission-common BT客户端 gnome-orca 屏幕阅读 webbrowser-app 自带浏览器 gnome-sudoku 数独 landscape-client-ui-install 管理服务 onboard 屏幕键盘 deja-dup 备份 libreoffice* 自带office套件 unity-webapps-common 亚马逊链接 安装常用软件(个人使用) 浏览器：chrome 输入法：搜狗输入法 办公：wpsdeb包下载字体缺失解决方案中文输入设置 音乐播放器：网易云音乐deb包下载 下载工具：uget+aria2 文本编辑：notepadqq vim sudo apt-get install vim git sudo apt-get install git JDK IntelliJ IDEA安装包下载安装教程 等等根据实际需求安装 使用体验用了几天的Ubuntu，单从桌面环境来说的话其实和用windows区别不大，大部分windows下的场景都能满足，只是由于刚开始不太习惯而且不熟悉导致花了较多时间在解决问题上面。幸好ubuntu的粉丝还比较多，在官方问答社区AskUbuntu或者善于利用Google都能找到不少问题的解决方案，减少自己折腾的时间。折腾完之后的系统基本能用了，但是离好用还有很大的距离，因为命令行操作才是linux系统高效解决问题的精髓，也是图形化之外的一大杀器，如果单纯为了用桌面和界面美化，那还不如回到windows的怀抱，根本不需要折腾闹人的linux。有好多人持有一种真的要学linux的话就不要装图形化界面，直接进行终端操作的观点，这种观点也是可以理解的，因为没有界面就不得不练习终端操作，只是过程非常的痛苦，很多时候因为不熟悉浪费更多的时间，到头来折腾了很久整个系统连能用都算不上，学习的曲线比较曲折。个人觉得倒不如先安装个有图形化界面的linux发行版保证能日常使用（这个比较推荐Ubuntu，有良好的社区支持、软件支持），然后日常逐步用命令取代点鼠标的操作，因为命令操作讲究的是熟悉度，一条命令打一半查一下是谈不上高效的，待熟悉了之后再逐步过渡到纯命令行操作，进入无鼠标的境界（有点久远）。不过这也就有一个问题，能否养成一种意识：在每次点鼠标之后都能想到去找相应的命令完成同样的任务并且接下来都不再使用鼠标，而这也应该是刻意练习的哲学吧。linux命令大全这个网站很好的收录了linux命令，剩下的就靠自己的造化了。最后附一张桌面图：]]></content>
      <categories>
        <category>实践记录</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜读《乌合之众：大众心理学研究》——我所理解的大众心理]]></title>
    <url>%2F2017%2F11%2F13%2F%E6%8B%9C%E8%AF%BB%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%EF%BC%9A%E5%A4%A7%E4%BC%97%E5%BF%83%E7%90%86%E5%AD%A6%E7%A0%94%E7%A9%B6%E3%80%8B%E2%80%94%E2%80%94%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%A4%A7%E4%BC%97%E5%BF%83%E7%90%86%2F</url>
    <content type="text"><![CDATA[旧文重发，原文地址：简书链接 书名：《乌合之众：大众心理研究》作者：古斯塔夫·勒庞译：冯克利关于本书《乌合之众：大众心理研究》是一本当之无愧的名著，他极为精致地描述了集体心态，是在社会心理学领域已经写出的著作中，非常有影响的。本书还具有持久的影响力，是群体行为的研究者不可不读的文献。本书被翻译成近二十种语言，至今仍在国际学术界有广泛影响。在本书中，作者指出，个人一旦进入群体中，他的个性便湮没了，群体的思想占据统冶地位，而群体的行为表现为无异议，情绪化和低智商。关于作者古斯塔夫·勒庞 (Gustave Le Bon 1841.5.7－1931.12.13)，法国社会心理学家、社会学家，群体心理学的创始人，有“群体社会的马基雅维里”之称。他出生于法国诺晋特-勒-卢特鲁（Nogent-le-Rotrou），逝于法国马恩-拉-科盖特（Marnes-la-Coquette）。——《百度百科》 前言德国纳粹法西斯主义在当今世界能否重现？根据真实事件改编的德国电影《浪潮》就告诉了我们答案。大学教师文格尔，通过体验式教学讲授独裁统治这个活动周课题，在短短五天内，就已经把一群学生培养成一群优秀的“纳粹分子”，他们摒弃了自己的个性，把集体的利益放在首位，甚至本着所谓的集体荣誉而做出了很多匪夷所思的过激行为，但是他们并没有意识到自己的行为已经过界，反而越演越烈，就连文格尔也深陷其中不能自拔，直到最后才醒悟过来，付出了沉重代价才结束这一场闹剧。暂且不提这样的课堂现象是否和中国教育类似，只是这部影片确实燃起我对大众心理学的兴趣，在活动周中的学生是处于一种什么的心理状态？什么是群体无意识行为？个人能否摆脱群体的控制？带着种种对大众心理的好奇心读完了这本书，希望《乌合之众》能给我一定的解释。于是便有了这篇文章，发表一些粗糙的见解。 全书结构 群体的时代 在各民族的生活中，有组织的群体历来起着重要的作用，然而这种作用从来没有像现在这样重要 这句话明显告诉我们，在勒庞著作此书的时候，他已经发现群体的重要性日渐显著，无疑是已经步入了群体的时代。为什么这么说呢？因为群众的声音已经慢慢得到了重视，至少在勒庞那个年代统治者如果想要稳固自己的统治就不能忽略群体，正所谓水能载舟、亦能覆舟。无论是罗马的灭亡还是阿拉伯帝国的建立，或者诸如此类的历史大动荡，其背后的深层原因，都是因为群体的思想、观念和信仰发生了极大的变化，进而使文明洗心革面。在当今世界，更是如此，网络的便捷令我们群众的声音更加容易汇聚成不可忽视的力量。 群体心理A.什么是群体通常的说法中，“群体”指的是聚集在一起的个人。而在心理学中，群体的定义是：在某些既定的条件下，并且只有在这些条件下，一群人会表现出一些新的特点，它非常不同于组成这一群体的个人所具有的特点。聚集成群的人，他们的感情和思想全都采取同一个方向，他们自觉的个性消失了，形成了一种集体心理。这就是所谓的心理集体。 《浪潮》中的学生们的感情和思想就离不开浪潮组织；而且这种心理集体并没有明确的时间和空间限制，在整个奥运会期间，绝大多数国民表现出来的爱国情怀也可以将他们归类为一个心理集体。 B.群体的一般特征 1.群体无疑总是无意识的 此书在多处地方都强调了群体无意识行为，或者说，**是具有一定种族特质的个人无意识行为汇聚成一个集体时所体现的群体无意识行为。**不同的人种会体现出不同的特质，留下一种专属印象，例如犹太人，就被认为是一种聪明的种族。或者拿身边的潮汕人来说，他们给大众留下的印象就是团结，而且听说过一种说法：一般的广东人在有不会听粤语的人在场的情况下会怕他听不懂而讲普通话，而潮汕人就不会有忌讳，一般两个潮汕人相互交流的话会直接讲潮汕话而不会顾及身边的人听不听得懂。这并不是一种歧视，而是想说，这是不是一种群体或者说个人的无意识行为呢？并没有经过思考语言的切换就直接说出了方言。这样看来的话，我们日常生活中的很多行为其实都是无意识支配的结果。那有意识的行为呢？ 勒庞认为：我们有意识的行为，是主要受遗传影响而造成的无意识的深层心理结构的产物。 解读这句话的话，应该就是说**我们现在的有意识行为都是由遗传造成的无意识行为继而发展而来的结果。如果从生物学的角度来看的话，我们的基因貌似会随着遗传而让我们更适合环境的需要，但是我们表现出来的行为却和教育等环境因素息息相关。基因会决定我们无意识的行为吗？没有仔细研究这个问题，但是有没有这样一种可能：我们从呱呱坠地开始，基因塑造着我们最基础的外形，然后我们在被称为种族的群体中慢慢生活着，自从有意识起就不断地为周围的人教化，我们被告诉说怎么做才是对的，慢慢地，有意识行为被内化成无意识行为，对于种族中的个体，由于在周围人的教化下，也有了一些种族的秉性。换句话说，就是种族演变的过程让种族的无意识行为有了一定的范式。**当然这只是一种纯粹的想法。可以看到的是，这种上升到种族层面的无意识行为对我们而言没有多少现实意义，有没有更一般的群体无意识行为呢？看完下文后，应该会有一定的见解。 2.群体中累加起来的只有愚蠢 勒庞指出：在心理集体中，个人的才智被削弱了。但是我认为，单独个体的智商并没有降低，而是说个体的纯粹理性思维被一些集体影响下的情绪所影响，没有去进行深入的思考，并且看待问题的出发点以及解决问题的方式也没有那么的专业化了，甚至说连脑都不想动了，因为他已经接受了集体中存在的更为普通平庸的观点，所以说，勒庞指出的个人才智，应该是表现出来的无脑行为而不是真实智力水平。 再者，在群体影响下的个人，会表现出一些孤立个体所不体现出的特点：1.群体的数量之多让群体中的个体成员有一种势不可挡的力量，这使他敢于发泄出自本能的欲望；而在独自一人的时候，必须加以克制这些行为。 这就让我想起了之前闹哄哄的打砸日货的不理智行为，情绪高涨之下人们的过激举动就明显体现出个人的行为约束被集体的力量所破除了。《浪潮》中的第三天学生全城粘贴喷涂浪潮logo的行为也从这里得到的合理的解释。2.在群体中，每种感情和行动都具有传染性，其程度足以使个人随时准备为集体利益牺牲他的个人利益。3.相互传染之下也让人们易于接受暗示，表现出特定的行为。《浪潮》中的教师文格尔，就是通过暗示学生们**纪律铸造力量、团结铸造力量、行动铸造力量**，慢慢的学生处在这种暗示的状态之中不再能够意识到自己的行为，甚至在相互传染下更加享受这种集体带来的归属感，也更加对“头领”文格尔唯命是从，马首是瞻。 群体中的个人不再是他自己，他变成了一个不受自己意志支配的玩偶。孤立的他可能是有个有教养的个人，但在群体中他却变成了野蛮人——即一个行为受本能支配的动物，他表现的身不由己，残暴而狂热。因此勒庞指出：群体在智力上总是低于孤立的个人，但是从感情及其激起的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质 C.群体的感情和道德观 1.群体是冲动的、多变的和急躁的。 群体不仅冲动而且多变。因为群体容易屈从于各种各样的刺激，所以群体的反应非常的多变而且这些刺激不受“大脑”的支配，从而也是冲动的。 2.群体是意受暗示的和轻信的 群体通常是处在一种期待注意的状态中，因此很容易受人暗示。最初的暗示，通过相互传染的过程，会很快进入群体中所有人的头脑，群体感情的一致倾向会立刻变成一个既成事实。所以，群体基本处于无意识的状态，在暗示的影响下表现失去了批判能力，变得极度轻信，而且一些事件在群体的形象思维中会被曲解的面目全非。 群体对自己看到的事件进行歪曲的方式，好像既多且杂，各不相同，因为组成群体的个人有着非常不同的倾向，但是情况并非如此。作为相互传染的结果，受到的歪曲是一样的，在群体的所有个人身上表现出同样的状态。 这也是一些集体幻觉的产生机制。大多数集体幻觉都是群体中的某个人对真相第一次歪曲之后传染暗示而群体又极度轻信的结果。这样的群体很容易“撒谎”，但是他们是无意识地撒谎，大多数他们认为的真相“”，都是传染过程中影响着同伴的个人幻觉。因此勒庞把史学著作当做纯粹想象的产物。它们是对观察有误的事实所做的无根据的记述，并且混杂着一些对思考结果的解释。 3.群体的情绪是夸张的和单纯的 群体表现出来的感情不管好坏，其突出的特点就是极为简单和夸张的。而这种夸张倾向只作用于感情，对智力完全不起作用。所以公众集会上的演说家一般都会信誓旦旦地夸大其词、并且绝对不以说理的方式证明任何事情——通过以极端感情来打动群体。 4.群体是偏执的、专横的和保守的 群体只知道简单而极端的感情；提供给他们的意见、想法和信念，他们或者全盘接受，或者一概拒绝，将其视为绝对真理或绝对谬论。而且他们所具有的专横和偏执特质不允许出现反驳者。同时他们又是保守的：他们对一切传统的迷恋与崇敬是绝对的，他们对一切有可能改变自己生活基本状态的新事物有着根深蒂固的无意识恐惧。 5.群体的道德水平或十分低劣，或极度高尚 如果道德指不断抑制私心的冲动，不违法犯罪的话，那么群体由于冲动和多变常常会表现得十分低劣；但是，如果把一时之间的美德，诸如自我牺牲，不计名利也算作道德的话，那么群体也会出现极高的道德境界。 勒庞在这一章节中，指出：**群体的某些特点，如冲动、急躁、缺乏理性、没有判断力和批判精神、夸大感情等等，几乎总是可以在低级进化形态的生命中看到，例如妇女、野蛮人和儿童。**或许是时代背景等因素的影响，才让勒庞对妇女、野蛮人和儿童有这么大的偏见和歧视，毕竟如今倡导男女平等的时代背景下把妇女和儿童和野蛮人混为一谈是一种错误的观念。低级生命与高级生命的主要区别在于智力水平，或者说是否由大脑处理外界刺激。如果是独立的个体，说话做事之前一般会经过大脑的考虑，想的周全，当然不排除有例外；而个体有了群体在背后当靠山之后，会有一种势不可挡的错觉，而且责任分散之后解放了个人束缚（类似于法不责众的观念），从而容易变得冲动无脑，并且自己没有经过深思熟虑的举动或者想法得到集体认同后会更偏向于坚定而不去思考对错，进而整个集体在传染和相互暗示下就表现出一些无脑行为。那群体中有没有理性的个体呢？会不会有一些很高明的想法被提出来然后大家乐于接受呢？肯定有，然而难度很大。毕竟感性和理性的争斗中，感性总是易于在群体中产生影响。虽然群体中的个体容易轻信一些观点和受暗示，但是理性的声音往往容易在情绪高涨的群体中被淹没甚至被感染。如果是极端的群体，在情绪亢奋下会因为偏执和专横而对不同的声音有排他性，甚至出现敌对行为。 就像《浪潮》最后集会时的那短短10几分钟所表现的：文格尔不断的暗示和鼓动大家，调动大家的高昂情绪，当原来的学生代表马尔科带着理性的声音成为异类的时候立即成为众矢之的，这个时候，多变的集体已经将曾经是引领者的他从浪潮中排除出去了。可以看出，处于集体中的个体如果没有一些非常震惊的外部刺激是很难在聚集的时候摆脱群体无意识的控制的，**因为周遭的人表现出惊人的一致性也让他认定了行为的正确性。**这是不是说，想要在集体中说服一个人的话，要和他抽离出集体的环境才可以开始分析呢？我觉得是。所以，群体中的个体在群体影响下做出的不受大脑支配的无意识行为让群体整体呈现出一些“低级生命”的特点 D.群体的观念、理性和想象力 1.群体的观念 群体能够接受的观念有两类：一种是那些因一时的环境影响来去匆匆的观念；另一种是基本观念，它们因为环境、遗传规律和公众意见而具有极大的稳定性。无论给群体什么观念，只有当它们具有绝对的、毫不妥协的和简单明了的形式时，才能够产生有效的影响。所以要让群体接受一个观念，必须将其改造的通俗易懂，还要经过长时间的作用下才得以进入无意识领域变成一种情感，这时的观念才会产生影响而且不容易改变。 2.群体的推理 勒庞指出：群体没有推理能力，因此也无法表现出任何批判精神，也就是说，它不能辨别真伪或对任何事物形成正确的判断。群体所接受的判断，仅仅是强加给他们的判断，而绝不是经过讨论后得到的采纳的判断。有些意见轻而易举就得到了普遍赞同，更多的是因为大多数人感到他们不可能根据自己的推理形成自己独特看法。 群体推理的特点，是把彼此不同、只在表面上相似的事物搅在一起，并且立刻把具体的事物普遍化。 3.群体的想象力 群体形象化的想象力不但强大而活跃，并且十分敏感。因为群体没有思考和推理能力，所以这种只会形象思维的群体，也只能被形象所打动。因此，要在思想上控制群体的话，在领导群体时，更要在这种想象力上下功夫。从某种意义上说，侵略者的权力和国家的威力，便是建立在群体的想象力之上的。那么如何影响群众的想象力呢？时刻铭记绝对不可以采用论证的方式，不管刺激群众的是什么，采取的形式都是令人吃惊的鲜明形象，并且没有任何多余的解释。 影响民众想象力的，并不是事实本身，而是它们发生和引起注意的方式 这一章节中，勒庞引出了群体的观念、群体的理性和群体的想象力这几个观点。不可否认，每一个聚集起来的群体里都会流传着各种各样的观念，而这些观念有的在群体中深深扎根，有些只是过眼云烟，也会有一些互相矛盾的观念在群体中共存。群体的观念都是个人观念堆积起来的产物。每个人都会有自己的观念，对观念也有自己的理解。就像民主平等、独裁统治，每个学生都会有自己的理解，而在群体的传染暗示作用之下，又会偏向一致，然后形成群体的观念。而且只要对观念的理解不会有很强烈的冲突，就可以共存，并且共存的观念会因为不同的时机而让人有不一样的行为表现。《浪潮》中，学生们认定文格尔先生为他们的领袖，允许文格尔先生领导他们，某种程度上认可了文格尔的“独裁”；而学生们相互之间就认为大家都是平等的，不应该有等级观念存在。因此，不同的观念会因群体对观念的形象理解偏差得以共存。而且，越容易理解的观念就越容易在群体中广泛传播。正如前面所论述的，群体累加起来的只有愚蠢。所以，即使群体中有极个别逻辑思维大牛，也不足以让整个群体表现出有很缜密的理性。说群体没有推理能力过于绝对了，只能说，整体水平不理想，毕竟越简单的东西就越容易得到普遍赞同，然后群体就会懒得去深思熟虑。当每个人对事物的想象加起来，一件东西就完全面目可非了。所以说，群体的想象力在任何情况下都不容忽视的，以讹传讹虽然听起来很不切实际，但是当放到群体的概念之中，有了传染暗示等作用时，好像也不难解释为什么大家对一些夸张化的事物深信不疑了。到目前为止发生过不少空难事件，但为什么MH370的空难事件能这么大范围的传播呢？因为这次空难的发生和引起注意的方式唤起了公众的想象力，诸如外星人之类的想法都不会让公众厌恶。 E.群体信仰所采取的宗教形式 勒庞指出宗教感情有着十分简单的特点：比如对想象中的某个高高在上着的崇拜，对生命赖以存在的某种力量的畏惧，盲目服从它的命令，没有能力对其信条展开讨论，传播这种信条的愿望，倾向于把不接受它们的任何人视为仇敌。一个人如果只崇拜某个神，他还不算有虔诚的信仰，只有当他把自己的一切思想资源、一切自愿的服从行为、发自肺腑的幻想热情，全都奉献给一项事业或一个人，将其作为自己全部思想和行动的目标和准绳时，才能说他是一个虔诚的人。 群体的信念有着盲目服从、残忍偏执以及要求狂热的宣传等这些宗教感情所固有的特点，可以说他们的一切信念都具有宗教的形式。 群众不管需要别的什么，他们首先需要一个上帝一切政治，神学或社会信条，要想在群众中扎根，都必须采取宗教的形式——能把危险的讨论排除在外的形式。即便有可能是群众接受无神论，这种信念也会表现出宗教感情中所有的偏执狂，它很快就会表现为一种崇拜。而这些宗教或政治信条的创立者之所以能够站得住脚，皆因他们成功地激起了群众想入非非的感情，他们使群众在崇拜和服从中找到了自己的幸福，随时准备为自己的偶像赴汤蹈火。 当一个群体拥有了自己的信仰，那么这个群体将会变得异常团结。为了信仰，他们能凝聚成一股洪流，冲破一切障碍。如果说《浪潮》中的学生是一个小型宗教组织也不为过，因为他们已经把浪潮运动当做他们的信仰，任何认同浪潮的人都可以成为洪流中的一滴水。他们中的绝大多数，已经把自己的满腔热血，无条件服从以及狂热的宣传奉献给了浪潮运动只为了浪潮这个集体可以发展得更为壮大。可以说，这样的群体是可怕的，因为他不容许别人亵渎他们的信仰，也就是说，这种群体会毫不犹豫的把反对声音排除出去。因此，在崇拜信仰的群体中也不存在危险的讨论了。这样看来的话，要是说从群体团结一心的角度来说，用信仰来控制群体貌似是个行之有效的方法，毕竟群体中如果存在各种各样的声音的话会很容易分裂；但是这种群体无疑是危险而且是不可控的，他们听不到其他的声音，会把信仰奉行到极致。或许，信仰带来的影响会使群体过于偏执和妄想。在如今，也有一些温和一点的字眼，诸如理念，可以说理念是求同存异的，它可以发挥信仰的积极影响——热情、奉献，而又不具排他性。当然，对信仰和理念的区别——是否排除异己，仅限于个人的理解，没有仔细研究。不过不可否认，在每个组织中都要有一些理念，从而让整个组织凝聚成不可忽视的力量。 结语完全没有想到，写着写着，居然已经写了那么长了，其实《乌合之众》这本书内容还有很多，一篇文章完全不足以涵盖所有内容，有兴趣的就去看这本书啦。总的文章架构是根据勒庞在书中提出的观点进行思考分析，只是简单发表下个人的一点点粗糙的见解而已。而且，还有从群体领袖的角度没有进行论述呢，有时间会再写一篇，专门研究群体领袖是如何“操纵”群体的。]]></content>
      <categories>
        <category>心得体会</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>心理学</tag>
        <tag>社会现象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习小结]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[实习告一段落，坐上回广州的大巴，搞好宿舍环境卫生、写完昨天落下的morris算法的代码实现，终于能够消停一会，好好回顾下刚过去不久的实习生涯。每一段经历都有值得回味的地方，如果不好好思考下，剩下的，就只是单纯的一段经历罢了。趁着8月的小尾巴，记忆尤新，赶紧把实习给总结了，主要为非技术篇，以后会再寻时间总结下实习学到的东西。 选择在大三刚开学不久的时候，就有去过深圳找大王（师姐外号），在南山区呆了一个周末，逛逛科技园，瞬间被周围林立的技术公司给震撼了，恩，当时就觉得深圳是个搞技术的好地方，而且恰逢双创在深圳举行，逛了一下之后，“创新创业”、“技术范”、“机遇”这几个词就已经深深烙在脑海里，成为我对深圳的初印象，并想象着以后能够来深圳工作，从此走上人生巅峰，哈哈。怀着对大公司的憧憬，开始“住在”实验室学习，没课的时候就往实验室跑，早出晚归，当然也会有偷懒的时候，不过相较于之前，学习已经有了相当多的时间占比。和大多数准备毕业就去工作的人一样，我也经历了各大公司的实习生招聘，并且不如人意，笔一家挂一家、面一家挂一家，心真的累，不过最后还是拿到了三个offer，开始了抉择，是要去金融的IT部门呢，还是去游戏公司呢，还是去深圳的软件公司呢，又或者利用暑假的时间，继续修炼技术呢？首先实习是必须的，提高自己对于企业开发的认知很有必要，因为之前做的小网站，小程序都是仅仅从功能实现的角度考虑而已，唯一的挑战就是功能如何去实现，而企业开发就不一样了，需要综合可维护性，稳定性以及性能优化等各种角度去思考问题。而自己对于这方面知识主要来源于网络博客和书，并没有一个很具体实质的概念。那么该选择去哪一家公司呢？金融的IT部门就不考虑了，从学校去到工作地点起码一个半小时，每天在路上就耗费太多时间，而游戏公司呢就很近，公司也在快速发展，而且对于实习生来说是以培养为主的，实习待遇也很不错，是挺想去的，但唯一让我有所保留的就是工作时间了，朝九晚八，一天下来剩不了多少自己的时间，虽然在程序猿这个职业，高工作强度是常态，但是目前还没准备好，也需要更多自己的时间去提高自己的技术水平。那就剩最后一个选项了，深圳！这个城市之前就一直吸引着我，而且实习待遇不错，有租房补贴，并且同班同学也获得了该公司的offer，公司比较大型，有成熟的体系，周末双休，综合权衡了实习公司、个人时间、待遇之后，就决定和同学一起来深圳这片土地发光发热。 实习体验步入职场在进入公司之后，才开始真正了解一个公司的内部运作，每一个内部员工都是一颗螺丝钉，为公司的正常运转而努力着。在刚开始实习的那几天，其实还是不太适应，在大学过于凌乱的生物钟一下子变得规律起来，还好一开始没有太多实质性的工作，都是看文档，学习内部的资料，了解部门的业务流程等等，有时间去调整自己的状态。还有一点不适应的是，周围的同事大多数都是中年人，聚在一起聊得都是孩纸，房和车，觉得身边没有同龄人有点孤独，还好部门内还有几个毕业一年左右的，还能说上话玩得开。不过有点遗憾，一开始以为会是写代码的工作，入职了才发现整个部门做的是性能部署相关的工作，也是这时候才意识到，员工的工作内容是随着部门业务变化而变化的，主要看需求，有时其他部门出现人员短缺也会调配人员去帮忙。换言之就是不会一直做本职工作，部门老大说过，几年前的时候，大家都是研发出身的，有问题谁有空就谁去解决，到后来分了一波人，专门负责应用系统的性能部署相关工作，再到现在有专门的部门负责这一块业务。其实也就是一个发展的过程，对于我个人而言，虽然我还是想去写代码，但是这实习恰好能够弥补我对性能方面知识的空缺，而且部门内部偶尔也会有开发任务，也还算过得去。最后一点感触就是，工作之后，就不像在大学时可以做自己想做的事情了。在大学的时候，时间几乎可以自己自由支配，想干啥干啥，偶尔不想去上课还可以翘课，但是工作之后就不一样了，工作时间需要完成分配的任务，偶尔还得加个班，学的东西也是围绕业务展开的，不像在学校实验室的时候，随时都可以学点感兴趣的技术，开始怀念还在学校的时候。 工作与个人生活的协调自从每天下班之后，才真正觉得时间是属于自己的，幸好实习生加班不多，每天大概7点多就回到了住处，偶尔晚点会8点多，曾经想每周写一篇技术博客的也由于时间方面的原因耽搁了，周末也有各种邀约。也是没有协调好时间的缘故吧，要做的事情太多，所支配的时间没处理好，常常看到很多文章都在教如何掌控下班后的几个小时，现在看来学会这个技巧还是挺有必要的，毕竟以后正式走向工作了免不了遇到同样的情况。不过这也和精力挂钩的，有时一天的工作太累，下班回来完全无心向学，只想玩游戏看美剧弹吉他，几乎不想动脑子，然后洗洗睡继续第二天上班，这样的情况也偶尔 会出现。亲身体会之后，才醒悟，自律果真是一门学问。 后记太久没有写东西，全文基本都是想到什么就写什么，不小心就写出了一篇小学流水账，惭愧，不过接下来应该会争取每周一篇博客的，恩，但愿如此。]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法解惑及代码实现]]></title>
    <url>%2F2017%2F08%2F06%2FKMP%E8%A7%A3%E6%83%91%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近在看左神的算法直播，其中讲了一个之前一直似懂非懂的算法——KMP，是一个在长字符串中找到匹配的模式串并返回模式串在长字符串的位置的算法，类似于常见的文本编辑软件所提供的Ctrl+F文本查找功能。早些时间看阮一峰的字符串匹配的KMP算法，初步理解KMP算法就是通过一个next数组记录模式串中前缀与后缀的最大匹配值，并利用这个信息来控制跳转的位置，以优化暴力方法中出现的没有必要的比较过程。在看了左神对KMP算法的解释后，决定梳理一下KMP算法，并且主要针对先前疑惑的几个点做一下阐释。 KMP算法由于阮一峰对KMP算法流程已经做了相当好的解释，在这里厚颜无耻的借用下其博客的部分内容（主要是图片），并且结合左神的思路梳理KMP流程（注：i为字符串的下标，初始为0；j为模式串的下标，初始为0）： 基本流程流程图解首先，长字符串”BBC ABCDAB ABCDABCDABDE”的首位字符（i=0）与模式串”ABCDABD”的首位字符(j=0)进行比较。因为B与A不匹配，所以模式串首位与长字符串第二位（i++）比较。 因为B与A不匹配，模式串首位与长字符串下一位（i++）比较 直到长字符串有一个字符，与模式串的首位字符相同为止。 接着比较长字符串和模式串的下一个字符（i++,j++），还是相同。 直到长字符串有一个字符，与模式串对应的字符不相同为止。 这时候，最简单粗暴并且容易想到的做法，就是将模式串从头开始和字符串回滚后的下一个字符比较（若pos为字符串与模式串首位相同的位置，则j=0，i=pos+1），也就是所谓的暴力枚举。显然，若字符串有n个字符，模式串有m个字符，那么时间复杂度为O(mn)，在数据量大的情况下是不可接受的 这时候，就轮到可以优化暴力枚举的KMP发挥作用了，其优化主要依赖于next数组,可以通过跳转到指定位置而不是从头开始来避免没有必要的比较 对应于模式串的下标，next数组记录着模式串中每一个字符前面的子串中前缀与后缀的最大匹配数值，如图为该模式串的next数组，具体介绍及计算方式下面会继续梳理。 当遇到不匹配的字符的时候(i=10,j=6) 模式串下标跳转到不匹配字符的next值2的位置，即j=next[6]=2。也就是说，字符串中不匹配的空格字符直接与”C”开始比较，其下标不需要回退 同理，模式串下标跳转到0位置，j=next[2]=0,继续比较 由于模式串首位也不匹配，于是回到流程一开始的地方，重复上述过程，直到完全匹配为止 完全匹配后，返回模式串在字符串中的位置，流程结束 talk is cheap,show the code123456789101112131415161718192021222324252627282930public int getIndex(String s,String m)&#123; //处理不合理输入 if (s == null || m == null || m.length() &lt; 1 || s.length() &lt; m.length()) &#123; return -1; &#125; //初始化 char[] schar = s.toCharArray(); char[] mchar = m.toCharArray(); int i = 0,j = 0; int slength = schar.length; int mlength = mchar.length; //获取模式串next数组 int[] next = getNextArray(m); //KMP流程 while(i&lt;slength&amp;&amp;j&lt;mlength)&#123; //若字符相同 if(schar[i]==mchar[j])&#123; i++; j++; &#125;else if(j==0)&#123;//字符不同，且此时模式串下标在首位 i++; &#125;else&#123;//字符不同，且发生在字符串比较中，需要跳转 j = next[j]; &#125; &#125; //流程结束，观察模式串是否已全部匹配完成 return j==mlength?i-j:-1; &#125; next数组详解KMP的核心就在于next数组的计算，再次明确下next数组的意义，next数组记录着对应位置的模式串字符前面最长相同前缀后缀长度，看上去很拗口，其实也就是这么个东西 前缀与后缀首先得理解前缀与后缀的概念，对于一个字符串abcde,前缀为a、ab、abc、abcd,后缀为bcde、cde、de、e。也就是说，前缀就是从第一个字符开始往后延伸，但不包含最后一个字符的字符串，后缀就是从最后一个字符开始往前延伸，但不包含第一个字符的字符串 next数组取值规则在模式串ABCDABD中，next数组如下：当j = 0时，前面没有任何字符，人为规定，其next值为-1，即next[0] = -1；当j = 1时，前面的字符串为A，其最长相同前后缀长度为 0，即next[1] = 0；当j = 2时，前面的字符串为AB，其最长相同前后缀长度为 0，即next[2] = 0；当j = 3时，前面的字符串为ABC，其最长相同前后缀长度为 0，即next[3] = 0；当j = 4时，前面的字符串为ABCD，其最长相同前后缀长度为 0，即next[4] = 0；当j = 5时，前面的字符串为ABCDA，其最长相同前后缀为A，即next[5] = 1；当j = 6时，前面的字符串为ABCDAB，其最长相同前后缀为AB，即next[6] = 2； next数组计算在next数组中，除了公认的next[0]=-1、next[1]=0外，其余每个位置的值都可以基于前一位计算出的next值得出结果 假定pos为待求next值的位置，pos-1则为上一次求值的位置，根据next[pos-1]可以知道其前缀与后缀的长度，temp为其前缀的下一个位置。显然，若temp位置上的字符与pos-1位置上的字符相同，则对于pos来说，其next值则在pos-1的next值基础上+1；若字符不同，则可继续利用已经求得的next[temp]值，比较t位置的字符与pos-1位置的字符是否相同，若相同，则对于pos来说，其next值则在temp的next值基础上+1如此反复，若每一次temp值都不匹配，最后得出next[pos]=0 看上去会有点凌乱，只要记住，next值指示的长度中，前缀和后缀的字符是一样的就会清晰很多了 talk is cheap ,show the code12345678910111213141516171819202122232425public int[] getNextArray(String m)&#123; if(m.length()==1)&#123; return new int[]&#123;-1&#125;; &#125; int[] next = new int[m.length()]; char[] mchar = m.toCharArray(); //固定值 next[0]=-1; next[1]=0; //从下标为2开始计算 int pos = 2; //最长相同前缀末尾+1的位置，初始为0 int temp = 0; while (pos &lt; next.length) &#123; if (mchar[pos - 1] == mchar[temp]) &#123; next[pos++] = ++temp; &#125; else if (temp &gt; 0) &#123; temp = next[temp]; &#125; else &#123; next[pos++] = 0; &#125; &#125; return next; &#125; 疑惑KMP优化过程的疑惑疑惑一如图，s为字符串，m为模式串，假设字符都相同，当分别到达i,j位置时，字符不同，根据KMP的规则，模式串j跳转到j’的位置（相同前缀后缀的长度）继续与i位置的字符比较。为什么模式串可以直接跳转到j’位置继续与i位置字符比较，而不需要重头开始比较？首先需要清楚，字符串与模式串到达i,j位置时才不相同，也就意味着其前面的所有字符都一一对应。根据next[j]可以得出m前缀与后缀是相同的，后缀又与s中后面的子串相同，m经过跳转后的m’在j’前面的子串又与m的前缀相同，因此图中四块圈起来的区域是相同的，跳转后j’之前的字符没有必要继续比较。这是KMP其中一个优化。 疑惑二如图，完全匹配后，是否存在一个更早的a位置,使得字符串与模式串相同，换言之，完全匹配后的模式串一定要从b位置开始吗？利用反证法，若存在一个a位置开头的模式串，那么在模式串m’中也必须存在一个a’，对应于a。这就使得j’前所表示的前缀变长，换言之，模式串中存在一个更长的相同前后缀，而原本next数组的值就是最长的相同前后缀，因此不符合要求，完全匹配的模式串的起始位置必定不早于b，因此b位置前的字符也没有必要继续比较。这是KMP的第二个优化。 小结因此，KMP优化过程中，免去了b位置之前不可能出现的情况以及b-i之间一定相同的情况的字符比较过程 next数组的计算过程比较对象的选择在next数组的计算过程中，为什么一定要选pos-1位置的字符与temp、temp=next[temp]、……等等位置上面的字符相比较呢？回想下next的定义——最长的相同前后缀长度，而前后缀分别始于第一个字符和最后一个字符，因此要计算后缀，必须得比较pos-1位置的字符。至于temp、t=next[temp]位置的选取，根据上图可知，依据pos-1的next值，我们可以发现下方前、后、前、后四块区域是完全一致的，因此在这个情况下要计算前缀则可以比较t与pos-1位置上的字符，以此类推…… 小结至此，KMP算法梳理完成]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典内部排序算法学习总结——算法思想、可视化、Java代码实现、改进、复杂度分析、稳定性分析]]></title>
    <url>%2F2017%2F07%2F17%2F%E7%BB%8F%E5%85%B8%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E3%80%81Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%94%B9%E8%BF%9B%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E3%80%81%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[此文属于旧文重发，原文章链接 什么是排序算法？排序，顾名思义，就是按照一定的规则排列事物，使之彼此间有序而排序算法所要做的工作，就是将数据按照人为制定的比较规则排列好，使数据处于彼此间有序的状态。 为什么要进行排序？那为什么要将数据排序呢？计算机处理速度这么快，会不会有点多此一举。现在考虑手上有一本目录乱序的词典，假设有1w个单词，如果想要查apple这个单词，每次都要从头开始找，一个个的确定是不是apple，忽略心力交瘁和砸字典的冲动，那么假设每次查找都需要12个小时。好，现在手上有一本有序的牛津词典，就是当今经常看到的这种，每次我们查apple这个词时，就可以根据字母的顺序，不到一分钟就可以找出apple的释义了。这样一看，有序与无序就相差了12个小时，而且是每次查找都节省12个小时，则让每个人都可以节省更多的时间去做其他的事情。类比到计算机也是一样的道理，节省下来的时间资源是巨大的，这种规模效益无疑值得我们去排序。 有时候，告诉一个人怎样去做一件事不如告诉他为什么要这么做。例如，告诉一个新手程序员怎样去优化一段代码，他有可能会拖延，但是告诉他说，一旦完成优化，每个用户浏览所花费的时间都会节省5秒。这样出来的效果是不一样的。——观点来源于网络 因此，觉得网络上很多文章一上来就直接说排序算法的思想以及如何实现是不够的。先要弄清楚为什么要排序，再去了解排序算法的细枝末节，毕竟所有排序算法，都是为了一个目的服务的——节约时间。 三、经典内部排序算法思想、可视化、Java代码实现、改进方法、时间复杂度、空间复杂度、稳定性结论先行，接下来会有大量篇幅去讲述排序算法的细节。为了方便，数组元素都使用整数。博客参考：八大排序算法十种排序算法总结视觉直观感受7种常用的排序算法常用排序算法稳定性、时间复杂度分析(转，有改动)常用排序算法时间复杂度分析十大经典排序算法|JavaScript描述 算法可视化网站：VisuAlgo书籍：Data Structures and Algorithm Analysis in Java (Thrid Edition) 冒泡排序BubbleSort介绍：冒泡排序是一种较为容易理解的排序算法，因为它就是相邻数两两比较，符合条件就交换位置而已，如果从小到大排的话，就像水中升起的泡泡一样越来越大 算法步骤：基于交换假设数组a[n]有N个整数第一趟，第一个数与第二个数比较，符合条件就交换位置，然后第二个数和第三个数比较，符合条件就交换位置，以此类推。如此，最后一个数字为最大数；第二趟，除去第一趟最后一个数字，第一个数与第二个数比较，符合条件就交换位置，如此类推，此时最后一个数字为本趟最大数第三趟，如上类推……第N-1趟，如上类推，所有交换完成后数组元素有序 可视化： Java代码实现：12345678910111213141516171819202122232425262728293031323334353637383940public class BubbleSort &#123; public static void sort(int[] a)&#123; int temp;//定义用于交换的临时变量 int length = a.length;//定义递减长度变量 //外循环，冒泡排序进行的趟数，取a.length-1是因为最后一趟只有一个数字，没有必要排序 for(int i=0;i&lt;a.length-1;i++)&#123; //内循环，实际进行两两比较 for(int j=0;j&lt;length-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; temp = a[j+1]; a[j+1] = a[j]; a[j] = temp; &#125; &#125; length--;//每趟结束后，最后一个数字有序且为该趟最大，下一趟排序不必进行比较 //用于在控制台输出每一趟的结果 System.out.println(); System.out.print(&quot;第&quot;+(i+1)+&quot;趟排序&quot;); for(int k = 0;k&lt;a.length;k++)&#123; System.out.print(a[k]+&quot; &quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;99,89,76,66,54,47,32,20,18,5&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; sort(a); System.out.println(); System.out.print(&quot;冒泡排序结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 改进方法：（1）设置标志位，每一趟循环开始默认有序，当发生交换时，则数组无序，仍需继续循环参考博客白话经典算法系列之一 冒泡排序的三种实现1234567891011121314151617181920public static void improveBubbleSort(int[] a)&#123; int temp;//定义用于交换的临时变量 int length = a.length;//length存储数组长度，可以避免每次循环中调用a.length方法的消耗 boolean flag = true;//设置标志位为ture，假设初始状态无序 //若无序，则进行循环 while(flag)&#123; flag = false;//假设元素正序 for(int i = 0;i&lt;length-1;i++)&#123; if(a[i]&gt;a[i+1])&#123; temp = a[i+1]; a[i+1] = a[i]; a[i] = temp; //若发生交换操作，则为无序状态，仍需进行下一次循环 //若不发生交换操作，则此步不会执行，则为正序，只需执行一趟循环 flag=true; &#125; &#125; &#125; &#125; （2）轮流从左到右以及从右到左进行冒泡排序参考博客：排序算法系列：冒泡排序与与双向冒泡排序 （3）同样是设置标志位，不过这个标志位用于记录最后一次发生交换的位置，则下一次循环只需要执行到该位置即可，因为后面的元素已经有序。 时间复杂度：与比较次数、逆序数有关，一次交换减少一个逆序最好情况为O($N$)。按照最开始的思路，假设元素一开始全部有序，但即使不需要交换，都需要不断循环比较，N个元素两两比较共需要$\frac{N(N-1)}{2}$次，再加上其他赋值等操作，所以时间复杂度为O($N^2$)；改进方法一，若元素一开始全部有序，则一次循环即可比较次数为N-1，再加上其他赋值等操作，所以时间复杂度为O($N$)。 最坏情况为O($N^2$)。元素一开始全部逆序，则逆序数有$\frac{N(N-1)}{2}$个，按照最开始的思路，则需要经历N-1趟，共$\frac{N(N-1)}{2}$次比较与交换，再加上其他赋值等操作，所以时间复杂度为O($N^2$)；采用改进一的算法，也需要进行N-1次循环，所以时间复杂度为O($N^2$)。 平均情况为O($N^2$)。书上定理：N个互异数的数组的平均逆序数是$\frac{N(N-1)}{4}$个；通过交换相邻元素进行排序的任何算法平均都需要O($N^2$)时间。为了消除对应的逆序数，所以时间复杂度为O($N^2$)。 空间复杂度：由于需要使用一个用于交换的临时变量temp，与数组规模N无关，所以空间复杂度为O(1) 稳定性分析：由于两相等元素在冒泡排序前后的相对位置不变（相等不发生交换），所以是稳定的 选择排序SelectionSort介绍：和冒泡排序一样通俗易懂，顾名思义，选择排序就是在待排序数组中选择出最小（最大）的元素，放到最前面；然后再在待排序数组中选出最小（最大）的元素放到前面，以此类推。 算法步骤：基于选择假设数组a[n]有N个整数，第一趟，从数组中找出数组中最小的元素，将其与第一位的元素交换位置第二趟，除去数组中的第一个元素，从剩下的元素中，找出最小的元素，将其与剩下的元素中的第一位交换位置……以此类推，第N-1趟，完成上述选择排序，数组有序也可以找出最大元素放在数组最后面，以此类推 可视化： Java代码实现：参考博客：白话经典算法系列之四 直接选择排序及交换两个数据的正确实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SelectionSort &#123; public static void sort(int[] a)&#123; int temp;//定义用于交换的临时变量 int length = a.length;//存储渐变数组长度 int maxPos = 0;//定义最大元素位置 for(int i = 0;i&lt;a.length-1;i++)&#123; //找出最大元素的位置 for(int j = 1;j&lt;length;j++)&#123; if(a[maxPos]&lt;a[j])&#123; maxPos = j; &#125; &#125; //交换数组元素的位置 temp = a[length-1]; a[length-1] = a[maxPos]; a[maxPos] = temp; length--;//除去最后那位最大的元素 maxPos = 0;//最大元素位置置0 //用于在控制台输出每一趟的结果 System.out.println(); System.out.print(&quot;第&quot;+(i+1)+&quot;趟排序&quot;); for(int k = 0;k&lt;a.length;k++)&#123; System.out.print(a[k]+&quot; &quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;99,74,25,88,54,63,41,33,4,17&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; sort(a); System.out.println(); System.out.print(&quot;选择排序结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 改进方法：（1）同时找最大的元素位置和最小元素的位置参考博客：排序算法（二）——选择排序及改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void improveSort(int[] a)&#123; int maxTemp;//定义用于交换的临时变量 int minTemp;//定义用于交换的临时变量 int length = a.length;//存储渐变数组长度 int maxPos;//定义最大元素位置 int minPos;//定义最小元素位置 //由于一趟确定两个数，所以趟数为原来的1/2 for(int i = 0;i&lt;a.length/2;i++)&#123; maxPos = i; minPos = i; //同时找出最大元素位置及最小元素位置 for(int j = i+1;j&lt;length;j++)&#123; if(a[maxPos]&lt;a[j])&#123; maxPos = j; &#125; if(a[minPos]&gt;a[j])&#123; minPos = j; &#125; &#125; //存储最大最小元素数值,最后用于覆盖首尾位置 maxTemp = a[maxPos]; minTemp = a[minPos]; //如果第一个元素不是最大最小值，就是需要保护的数值,需要找一个不是首尾位置的地方存储，优先考虑maxPos和minPos if(a[i]!=maxTemp&amp;&amp;a[i]!=minTemp)&#123; if(maxPos!=i&amp;&amp;maxPos!=length-1)&#123;//如果最大元素位置不是首尾，则可以覆盖 a[maxPos]=a[i]; &#125; if(minPos!=i&amp;&amp;minPos!=length-1)&#123;//如果最小元素位置不是首尾，则可以覆盖 a[minPos]=a[i]; &#125; &#125; //如果最后一个元素不是最大最小值，就是需要保护的数值，需要找一个不是首尾位置的地方存储，优先考虑maxPos和minPos if(a[length-1]!=maxTemp&amp;&amp;a[length-1]!=minTemp)&#123; if(maxPos!=i&amp;&amp;maxPos!=length-1)&#123;//如果最大元素位置不是首尾，则可以覆盖 a[maxPos]=a[length-1]; &#125; if(minPos!=i&amp;&amp;minPos!=length-1)&#123;//如果最小元素位置不是首尾，则可以覆盖 a[minPos]=a[length-1]; &#125; &#125; //最后覆盖首尾位置 a[i] = minTemp; a[length-1] = maxTemp; length--;//除去最后那位最大的元素 &#125; &#125; 注意，在这种同一个循环中，既要交换最大位置元素，又要交换最小位置元素的情况。如果先后交换，如swap(a[maxPos],a[length-1])swap(a[minPos],a[i])则最先的那个交换有可能会改变后一次交换最小位置原本的数值，如minPos==length-1 时间复杂度：最好情况、最坏情况、平均情况均为O($N^2$)采用改进前的算法，无论数组元素全部有序还是全部无序，都需要执行N-1趟共$\frac{N(N-1)}{2}$次比较来确定最大（小）值，再加上其他赋值等操作，平均也需要时间复杂度O($N^2$)。即时采用改进后的算法，趟数减少一半，但是一趟的比较次数增加一倍，时间复杂度还是O($N^2$)。 空间复杂度：需要的额外辅助空间（用于交换等）与数据规模大小无关，所以为O(1) 稳定性分析：由于先扫描先排序，从左到右进行的话，相等的元素a左有可能被置于右边，相等的元素a右有可能被置于左边，所以是不稳定的 插入排序InsertiontSort介绍：插入排序也是比较容易的排序算法之一，主要是将待排序的数组的每一个元素插入到有序数组的对应位置上 算法步骤：基于插入假定数组a[n]有N个元素，同时假设第一个元素a[0]位于有序区，剩余元素皆位于无序区第一趟，将无序区的第一个元素a[1]，插入到有序区中，若比a[0]小，则将a[0]的数右移到a[1]处，将a[1]的元素插入到a[0]的位置上，有序区为a[0]、a[1]第二趟，将无序区的第一个元素a[2]，插入到有序区对应的位置上，相应的元素移动使有序区维持有序，……第N-1趟，完成插入操作，数组有序 可视化： Java代码实现：1234567891011121314151617181920212223242526272829303132333435363738public class InsertionSort &#123; public static void sort(int[] a)&#123; int temp;//定义临时变量用于存储待插入元素 int length = a.length; //存储数组a的长度 int pos;//定义要插入的位置 //开始遍历，无序区从a[1]开始 for(int i = 1;i&lt;length;i++)&#123; temp = a[i]; for(pos = i;pos&gt;0&amp;&amp;temp&lt;a[pos-1];pos--)&#123; a[pos] = a[pos-1]; &#125; a[pos] = temp; //用于在控制台输出每一趟的结果 System.out.println(); System.out.print(&quot;第&quot;+i+&quot;趟排序&quot;); for(int k = 0;k&lt;a.length;k++)&#123; System.out.print(a[k]+&quot; &quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;99,74,25,88,54,63,41,33,4,17&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; sort(a); System.out.println(); System.out.print(&quot;插入排序结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果 改进方法：（1）直接插入排序通过顺序比较来确定插入点，比较次数较多，而这可以通过二分查找的方法在有序区中确定插入点来减少比较次数，快速定位插入点。参考博客：排序算法（三）——插入排序及改进 时间复杂度：最好情况为O($N$)。如果数组一开始全部有序，则只需要进行一遍外循环即可，内循环因条件不成立无法开始，此时时间复杂度O($N$)最坏情况为O($N^2$)。如果数组一开始反序，则需要经过N-1趟共$\frac{N(N-1)}{2}$次比较和移动，再加上其他操作，则时间复杂度为O($N^2$)平均情况为O($N^2$)。从某种意义上看，插入排序隐含地通过交换相邻元素完成排序（待插入元素与被移动元素逐一交换），因此也可看做与逆序数相关，平均逆序数$\frac{N(N-1)}{4}$个，因此时间复杂度为O($N^2$)。 空间复杂度：由于所需额外辅助空间与数据规模N无关（只需要一个临时存储待插入元素空间），因此空间复杂度为O(1) 稳定性分析：因为相等的元素，位于左边的先进入有序区，右边的进入有序区后也不会插入等左的左边，因此是稳定的 希尔排序ShellSort介绍：插入排序的升级版，使用不同的增量依次把原数组分割成不同的子序列，对每个子序列进行插入排序，随着算法的进行，增量逐渐减少，直到比较相邻元素的最后一趟排序为止，因此希尔排序也叫做缩减增量排序。因为插入排序对有序的情况效率较高，而随着算法的进行，数组元素趋于有序，所以希尔排序的效率也比较高 算法步骤：基于插入假设数组a[n]有N个元素，选择增量为{1,3,5}第一趟排序，根据增量为5，将原数组分割为5个子序列，如{a[0]、a[5]、a[15]、……}、{a[1]、a[6]、a[11]、……}、{a[2]、a[7]、……}、……，依次对处于这些位置的序列进行插入排序第二趟排序，根据增量为3，将第一趟排序结果分割为3个子序列，如{a[0]、a[3]、a[6]、……}、{a[1]、a[4]、a[7]、……}、……依次对处于这些位置的序列进行插入排序第三趟排序，因为增量为1，对上一趟排序结果进行插入排序，算法结束 可视化： Java代码实现：1234567891011121314151617181920212223242526272829303132333435363738public class ShellSort &#123; //以N/2、N/4、……为增量序列 public static void sort(int[] a)&#123; int pos;//定义要插入的位置 int temp;////定义临时变量用于存储待插入元素 int length = a.length; for(int gap = length/2;gap&gt;0;gap/=2)&#123;//根据增量确定趟数 for(int i = gap;i&lt;length;i++)&#123;//执行插入排序，从0到gap-1为每子序列的有序区 temp = a[i]; for(pos = i;pos&gt;=gap&amp;&amp;temp&lt;a[pos-gap];pos-=gap)&#123; a[pos] = a[pos-gap]; &#125; a[pos] = temp; &#125; //用于在控制台输出每一趟的结果 System.out.println(); System.out.print(gap+&quot;排序后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;99,74,25,88,54,63,41,33,4,17&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; sort(a); System.out.println(); System.out.print(&quot;插入排序结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果 改进方法：（1）希尔排序的运行时间依赖于增量序列的选择，通过改变增量序列，来改进算法的运行时间。 时间复杂度：目前只有最坏情况时间复杂度，其他情况尚无结论，由于过于复杂，所以一般很少用希尔排序使用希尔增量时，最坏情况时间复杂度为O($N^2$)使用Hibbard增量时，最坏情况时间复杂度为O($N^\frac{3}{2}$) 空间复杂度：与插入排序类似，额外辅助空间与数组元素规模N无关，所以空间复杂度为O(1) 稳定性分析：由于不同趟之前会彼此打乱相等元素的相对位置，所以希尔排序是不稳定的 堆排序HeapSort参考博客：常见排序算法-堆排序 介绍：和选择排序类似，堆排序也是从待排序数组中选择出最大（小）值，然后进行多趟选择完成排序，但是堆排序相对直接选择排序一个很大的区别在于，堆排序利用了堆这种数据结构——堆可以看成完全二叉树，所以每个节点可以对应数组元素，其堆序性质，父节点比子节点大（父节点比子节点小）进而使堆为最大（小）堆，根节点是最大（小）的。因此，堆排序实际上就是不断地取出根节点，然后调整堆结构维持堆序性质，再取出根节点……最后取出的元素序列有序。 算法步骤：基于选择假设数a[n]有N个元素，要求排序后的数组从小到大，第一趟，以线性时间建立一个最大堆，以层序遍历的方式对应数组的位置（下标从0开始），则a[0]为根节点，交换此时a[0]与a[n-1]的位置，此时被放到最后的元素已经不再属于堆，然后对改变后的堆执行下滤（将a[0]放到合适的位置），成立一个新堆。第二趟，再次交换数组首尾位置的元素，此时被放到最后的元素已经不再属于堆，接着对改变后的堆执行下滤操作（将a[0]放到一个合适的位置），重新建立堆。……以此类推，第N-1趟后，数组有序 可视化： Java代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class HeapSort &#123; //找出节点的左儿子,数组下标从0开始，则节点pos的左儿子为2pos+1，右儿子为2pos+2 private static int leftChild(int pos)&#123; return 2*pos+1; &#125; //执行下滤操作，维持堆序性质 private static void percDowm(int[] a,int pos,int length)&#123; int child;//子节点的下标 int temp;//定义临时变量用于存储被下滤的节点元素 //下滤操作，按照父节点比子节点大的堆序性质，找出某一节点合适的position for(temp=a[pos];leftChild(pos)&lt;length;pos=child)&#123; child = leftChild(pos); if(child!=length-1&amp;&amp;a[child]&lt;a[child+1])&#123;//如果左儿子不是尾节点，则肯定有右儿子。找出两个儿子中最大者 child++; &#125; if(temp&lt;a[child])&#123;//子节点若比父节点大，则子节点元素移到父节点的位置 a[pos]=a[child]; &#125; else&#123; break; &#125; &#125; a[pos] = temp; &#125; public static void sort(int[] a)&#123; int length = a.length; int temp;//定义临时空间用于交换 //建立一个堆，不考虑树叶（树叶没有子节点） for(int i=length/2-1;i&gt;=0;i--)&#123; percDowm(a, i,length); &#125; //提取最大元素，并调整堆结构 for(int i=0;i&lt;a.length-1;i++)&#123; temp = a[0]; a[0] = a[length-1]; a[length-1] = temp; length--;//除去最后一位元素 percDowm(a,0,length); //用于在控制台输出每一趟的结果 System.out.println(); System.out.print(&quot;第&quot;+(i+1)+&quot;趟排序&quot;); for(int k = 0;k&lt;a.length;k++)&#123; System.out.print(a[k]+&quot; &quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;99,74,25,88,54,63,41,33,4,17&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; sort(a); System.out.println(); System.out.print(&quot;堆排序结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 时间复杂度：与建立堆时以及下滤时的比较次数有关，平均情况，最好情况，最坏情况。均为$O(N\log N)$. 书中定理，对N个互异项的随机排列进行堆排序所用比较的平均次数为$2N\log N-O(N\log N)$ 因此平均情况时间复杂度为$O(N\log N)$，而且，无论什么情形，基本都要进行这么多次比较以及其他操作，所以平均情况，最好情况，最坏情况的时间复杂度均为$O(N\log N)$. 空间复杂度：由于额外辅助空间与数据规模大小N无关，所以为O(1) 稳定性分析：由于连续的下滤操作会打破堆的结构，因此是不稳定的 归并排序MergeSort介绍：归并排序运用经典的分而治之策略，其将问题分成一些小的问题进行递归求解，而治的阶段则将分的阶段解得的各答案修补在一起。 算法步骤：基于递归假设数组a[n]有N个元素，首先申请一个具有同样空间大小的数组，用于存放最后的有序数组要对这N个元素进行排序，则可以通过将其分成前后两半，分别排序后进行合并同理，要对前后两半序列排序，则可以先把前半部分再分成两半，分别排序后合并，对于后半部分也是如此如此多次递归之后，排序变成对基准情况——只有一个元素的序列（因为一个元素默认其有序）进行合并，得出的结果再返回进行合并，多次合并后，最后数组元素有序 如何合并两个有序序列呢？两个序列从起始位开始比较，较小（大）的放到临时数组中，然后相关的指针指向下一个元素，再次进行比较，当其中一个序列完成所有比较后，则将另外一个序列剩余部分放到临时数组中 可视化： Java代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MergeSort &#123; /* * 归并排序内部实现 * a 为待排序数组 * tempArray 为临时数组，用于存储合并之后的结果 * left 要执行归并排序的序列头 * right 要执行归并排序的序列尾 */ private static void mergeSort(int[] a ,int[] tempArray,int left,int right)&#123; if(left&lt;right)&#123; int center = (left +right)/2; mergeSort(a, tempArray, left, center);//对左半部分递归执行归并排序 mergeSort(a, tempArray, center+1, right);//对右半部分递归执行归并排序 merge(a,tempArray,left,center+1,right);//合并左右两半部分 &#125; &#125; /* * 合并两个有序序列 * a 为待排序数组 * tempArray 为临时数组，用于存储合并之后的结果 * leftPos 数组左半部分的比较位置 * rightPos 数组右半部分的比较位置 * rightEnd 数组右半部分的末尾 */ private static int[] merge(int[] a,int[] tempArray,int leftPos,int rightPos,int rightEnd)&#123; int leftEnd = rightPos-1;//数组左半部分的末尾 int tempPos = leftPos;//在临时数组中存放元素的位置 int num = rightEnd-leftPos+1;//需要合并的元素数量 //左右两半部分有序序列，从初始位置开始比较，较小的放进临时数组中，之后相应的位置指针右移 while(leftPos&lt;=leftEnd&amp;&amp;rightPos&lt;=rightEnd)&#123; if(a[leftPos] &lt;= a[rightPos])&#123; tempArray[tempPos++]=a[leftPos++]; &#125;else&#123; tempArray[tempPos++]=a[rightPos++]; &#125; &#125; //若左边序列还有剩余未比较元素，则全部复制到临时数组中 while(leftPos&lt;=leftEnd)&#123; tempArray[tempPos++] = a[leftPos++]; &#125; //若右边序列还有剩余未比较元素，则全部复制到临时数组中 while(rightPos&lt;=rightEnd)&#123; tempArray[tempPos++] = a[rightPos++]; &#125; //最后把完成合并的临时数组的元素复制回原数组a中 for(int i = 0;i&lt;num;i++,rightEnd--)&#123; a[rightEnd] = tempArray[rightEnd];//rightEnd为完成合并的序列末尾元素在数组中的位置 &#125; //用于在控制台输出每一趟的结果 System.out.println(); System.out.print(&quot;归并排序&quot;); for(int k = 0;k&lt;a.length;k++)&#123; System.out.print(a[k]+&quot; &quot;); &#125; return a; &#125; //外部可调用的归并排序 public static void sort(int[] a)&#123; int[] tempArray = new int[a.length];//创建临时数组 mergeSort(a, tempArray, 0, a.length-1);//开始归并排序 &#125; public static void main(String[] args) &#123; int[] a = &#123;99,74,25,88,54,63,41,33,4,17&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; sort(a); System.out.println(); System.out.print(&quot;归并排序最终结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 时间复杂度：最好、最坏、平均情况均为$O(N\log N)$关于递归算法的时间复杂度分析可以了解主项定理的相关知识主项定理——算法复习笔记对递归程序进行分析必须要有运行时间的递归关系。在这里，当N=1时，归并排序运行时间是常数，记为1；当对N个数进行排序时，其用时等于完成两个大小为N/2的递归排序再加上线性的合并时间，因此可得递归关系：$T(1)=1$$T(N)=2T(N/2)+N$最后解出$T(N)=N\log N+N$，所以时间复杂度为$O(N\log N)$，而这无论是最好最坏情形还是平均情形都是基本不变的 归并排序的运行时间严重依赖于比较元素和在数组中（以及临时数组）中移动元素的相对开销，而这些开销是和语言相关的。在Java中，执行一次泛型排序（使用Comparator）时，进行一次元素比较可能是昂贵的（因为比较可能不容易被内嵌，从而动态调度的开销可能会减慢执行的速度），但是移动元素则是省时的（因为他们是引用的赋值，而不是庞大对象的拷贝）。归并排序是流行算法中比较次数最少的，因此适用于使用Java的通用排序算法，而它就是标准Java类库中泛型排序所使用的的算法在C++的泛型排序中，如果对象庞大，那么拷贝对象可能需要很大的开销，而由于编译器具有主动执行内嵌优化的能力，因此比较对象常常是省时的，因此，C++最好使用比较次数多而移动数据少的算法，其标准库中常使用的是快速排序 空间复杂度：由于需要一个额外的数组来存储归并之后的结果，其大小与N的大小有关，因此空间复杂度为O(N) 稳定性分析：由于递归合并的操作并没有打乱两相等元素的相对位置，因此是稳定的 快速排序QuickSort参考博客：白话经典算法系列之六 快速排序 介绍：快速排序是实践中一种快速的排序方法，在C++中或对Java基本类型的排序中特别有用。和归并排序一样，快速排序也是一种分治的递归算法。 算法步骤：假设数组a[n]有N个元素首先从数组中选出一个枢纽元，然后把元素分成两个部分，一部分比枢纽元大，另一部分比枢纽元小，枢纽元位于两部分之间，则枢纽元处于排序后正确的位置上；从两部分元素集合中各自选择枢纽元，如上述所示将其所在集合分成两个部分不断递归子集合，直到基准情况——子集合中元素个数是0或1时,，最后数组有序 可视化： Java代码实现：123456789101112131415161718192021222324252627282930313233343536373839public class Quick &#123; public static void quickSort(int[] a,int left,int right)&#123; if(left&lt;right)&#123; int pivot = a[left];//以第一个数作为枢纽元（挖坑） int i = left,j=right; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;a[j]&gt;=pivot)&#123;//从右边起找第一个小于枢纽元的数 j--; &#125; if(i&lt;j)&#123; a[i++]=a[j];//填上坑，并再挖坑 &#125; while(i&lt;j&amp;&amp;a[i]&lt;=pivot)&#123;//从左边起找第一个大于枢纽元的数 i++; &#125; if(i&lt;j)&#123; a[j--] = a[i];//填上坑，并再挖坑 &#125; &#125; a[i] = pivot;//最后用枢纽元填坑 //递归两部分数组 quickSort(a, left, i-1); quickSort(a, i+1, right); &#125; &#125; public static void main(String[] args) &#123; int[] a = &#123;99,74,25,88,54,63,41,33,4,17,45,66,89,3,25,4,7&#125;; System.out.print(&quot;原数组：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; quickSort(a, 0, a.length-1); System.out.println(); System.out.print(&quot;快速排序最终结束后：&quot;); for(int i = 0;i&lt;a.length;i++)&#123; System.out.print(a[i]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 改进方法：（1）参考书籍：《数据结构与算法Java语言描述》例程参考博客：三种快速排序的算法以及快速排序的优化 关于枢纽元的选择——最好选择数组的中值常见的做法是选择第一个元素作为枢纽元，但是在这种选择下，如果元素已经有序（正序或反序），则分割成两半的时候就会将全部元素分割到其中一个集合中，而且对以后的递归过程也是如此。较好的做法是采用三数中值分割法——使用左端、右端和中心位置上的三个元素的中值作为枢纽元，这样可以消除预排序的坏情形关于分割策略——如何将小元素移到数组的左边，把大元素移到数组的右边。策略有很多种，这里使用一种已知是安全的首先，将枢纽元与最后的元素交换使枢纽元离开被分割的数据段。定义两个变量i，j，其中 i 从第一个元素开始，而 j 从倒数第二个元素开始当 i 在 j 的左边时，将 i 右移，移过那些小于枢纽元的元素，并将 j 左移，移过那些大于枢纽元的元素。则当 i 和 j 停止时， i 指向一个大元素而 j 指向一个小元素，这时如果 i 还在 j 的左边，则交换两个元素的位置。然后重复上述过程，知道 i 和 j 彼此交错最后，交换枢纽元与 i 所指向的元素（因为小于位置 i 的必定是小元素，大于位置 i 的必定是大元素）对于与枢纽元相等的元素，则让 i 和 j 停止关于小数组（N&lt;=20时）,插入排序比快速排序更有效率。所以通常对于小数组更倾向于使用插入排序这种排序算法，相对于自始至终使用快速排序可以节省15%的运行时间。分界通常选取N=1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class QuickSort &#123; private static void swap(int[] a,int left,int right)&#123; int temp; temp = a[left]; a[left] = a[right]; a[right] = temp; &#125; /* * 三数中值分割法选择枢纽元 * * 对a[left]、a[right]、a[center]适当的排序后，取中值作为枢纽元。 * 此时三元素的最小者位于a[left]，是恰当的位置，最大者位于a[right]也是恰当的位置， * * 而把枢纽元放到a[right-1]上并在分割阶段将i和j初始化为left+1和right-2。 * 此时a[left]可以充当j的哨兵 * 而且由于i将停在那些等于枢纽元的元素上，所以枢纽元放在a[right-1]上也可以充当i的哨兵 */ private static int medianPivot(int[] a,int left,int right)&#123; int center = (left+right)/2; //三数排序，中值为枢纽元 if(a[center]&lt;a[left])&#123; swap(a,left,center); &#125; if(a[right]&lt;a[left])&#123; swap(a,left,right); &#125; if(a[right]&lt;a[center])&#123; swap(a,center,right); &#125; //把枢纽元放在right-1的位置上 swap(a,center,right-1); return a[right-1]; &#125; //快速排序内部例程 private static void quickSort(int[] a,int left,int right)&#123; //数组规模N&gt;10使用快排,N&lt;=10使用插入排序 if(left + 10 &lt;= right)&#123; int pivot = medianPivot(a, left, right);//三数中值分割法已经把left与right-1位置上的元素分成两部分 int i =left,j=right-1; for(;;)&#123; while(a[++i]&lt;pivot)&#123;&#125; while(a[--j]&gt;pivot)&#123;&#125; if(i&lt;j)&#123; swap(a,i,j); &#125;else&#123; break; &#125; &#125; swap(a,i,right-1);//把三数取中值时放在right-1上的枢纽元放到i的位置 quickSort(a, left, i-1); quickSort(a, i+1, right); /* * 如果33行~42行代码写成如下，则会可能由于a[i]=a[j]=pivot,即都等于枢纽元的情况而产生无限循环 * * int i = left+1,j=right-2; for(;;)&#123; while(a[i]&lt;pivot)&#123;i++;&#125; while(a[j]&gt;pivot)&#123;j--;&#125; if(i&lt;j)&#123; swap(a,i,j); &#125;else&#123; break; &#125; &#125; */ &#125;else&#123; InsertionSort.sort(a); &#125; &#125; public static void sort(int[] a)&#123; quickSort(a, 0, a.length-1); &#125;&#125; 时间复杂度：快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次比较最好情况为$O(N \log N)$。枢纽元刚好位于中间，则每次划分使左右两个无序区间长度大致相等，则有点类似于二分法，此时总的比较次数O($N \log N$)。最坏情况为$O(N^2)$。枢纽元始终是最小或最大元素，则每次划分全部元素在一边，另一边为空，此时总的比较次数为$O(N^2)$。平均情况为$O(N \log N)$。证明略复杂，详细可参考《数据结构与算法Java语言描述》P205 空间复杂度：与递归时造成的栈空间使用有关。平均来说，递归树的深度为$ \log N$，所以空间复杂度为$O( \log N)$ 稳定性分析：假设两个相等的数大于枢纽元且均位于左边，则等左的数会比右边的数先填到右边的坑里，排序完成后相对位置改变，所以是不稳定的 桶排序BucketSort/基数排序RadixSort/计数排序CountingSort介绍：这三种排序都使用了桶的概念，即不比较而是通过分配再合并的方式进行排序，只是分配的方法不一样。在计数排序中，每个桶存储一个特定的值，扫描待排序数组，值对应的放进桶中，最后将桶中元素倒出，最后数组有序在桶排序中，给每个桶划定一定的范围，扫描待排序数组，将每个数放在对应范围的桶里面，再分别对每个桶排序（插排、快排等），最后将每个桶里面的元素有顺序的倒出，最后数组有序。在基数排序中，对应元素的不同位数，如整数元素就可以对其百位数、十位数、个位数；字符串就可以对其不同位数上的字母，分别使用桶排序。 这几个使用桶概念的算法，都需要对待排序数组的情况有一定了解，例如数据量太大，就不适合使用计数排序，因为桶分配太多会浪费资源；数据间隔大但数据少，使用桶排序则不好划分范围等。但是就不代表不要用这些排序，事实上，如果选择合适，还是可以使用这些算法思想进行排序的，因为这几个排序是为数不多的可以以线性时间O(N)进行排序的算法。 关于更多内容可以参考博客十大经典排序算法|JavaScript描述中这几个排序的相关内容。 交叉比较总结参考博客：八大排序算法 时间复杂度：一般而言，$O(N^2)$型的有：冒泡排序、选择排序、插入排序$O(N \log N)$型的有：快速排序、归并排序、堆排序$O(N)$型的有：基数排序、桶排序、计数排序 但是特殊情况，根据不同算法时间复杂度所依赖情况的不同，如输入基本有序时，则会让插入排序以及改进的冒泡排序节省大量比较次数而变得更快$O(N)$，但是却让以首元素作为枢纽元的快速排序变得很糟糕$O(N^2)$。除此之外，输入的情况对选择排序，堆排序，归并排序还有基数排序影响不大。 空间复杂度：冒泡排序、选择排序、插入排序、堆排序、希尔排序的空间复杂度均为$O(1)$而快速排序与归并排序由于使用递归、其空间复杂度不仅依赖于额外空间的使用，还依赖于递归树的深度。 稳定性稳定的排序算法，冒泡、插入、归并、基数不稳定的排序算法，选择，快速，希尔，堆 一些排序算法的选择准则对输入的考虑因素： 数据记录条目N的大小 数据记录的结构与分布情况（如关键字的间隔、是否有序以及相等的个数等等） 内存空间的要求 稳定性要求 因此，当N较大时，可以考虑$O(N \log N)$型排序一般使用快速排序（目前基于比较的内部排序算法中最好的），其次如果不要求稳定性的可以使用堆排序，要求稳定性但内存空间允许的情况下基本使用归并排序当N较小时，可以使用一些简单的算法，如冒泡排序、选择排序、插入排序。如果了解输入情况（如输入有序等），可以使用插入排序或改进的冒泡排序如果不了解输入情况且不要求稳定性的，一般使用选择排序特殊情况下还可以尝试基数排序、桶排序等 后记上述内容仅为学习总结，如有错误希望能够指出，也希望有人不吝赐教]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机——自动内存管理机制》笔记与心得]]></title>
    <url>%2F2017%2F07%2F08%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E3%80%8B%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[好像好久没有码字了，之前要么忙考试，要么忙实习，再加上拖延症发作，兜兜转转，时隔多日终于有了更新，估计近期也都是周更吧，白天实习，晚上写代码，再加上点娱乐时间，也就剩下周末有时间准备码字了。由于实习的工作中涉及到JVM的内容会比较多，之前看书就只知道点概念而已，而且一直不知道学会JVM之后能拿来干嘛，现在终于有了点初步了解——分析Java程序运行时的状态，对程序进行性能调优以及维持程序的稳定性。为了能够更好的应对实习工作，下班后抽时间稍微看了下《深入理解Java虚拟机》，并重点关注JVM的自动内存管理机制，顺便对书中内存管理相关内容做下总结。 自动内存管理机制在日常的开发中，我们写Java代码的大多会将注意力集中在业务逻辑上，只要能实现功能且不出bug就谢天谢地了，几乎不用操心内存泄露和内存溢出之类的问题，因为这些东西JVM已经帮我们搞定了，但是我们能够保证大型应用系统一定不会出现内存相关问题吗？肯定不能，那么一旦出问题，不熟悉JVM的话怎么能够及时排除故障，维持业务的正常运作呢？要具备问题的分析处理能力，就得知己知彼，了解JVM的相关机制，本文主要涉及自动内存管理机制。 Java内存模型JVM在执行Java程序的过程中会把内存区域划分为几个数据区域，不同的区域功能特点各不相同。 程序计数器我们都知道java程序在执行过程中需要先被编译为字节码，然后才可以被解释执行。程序计数器的作用可以看成是当前线程所执行字节码的行号指示器，通过它虚拟机就可以知道下一条需要执行的字节码指令是什么。在多线程环境下，由于各个线程会轮流切换占用CPU时间，因此为了让每个线程都能在切换后正确工作，就需要每个线程都带有一个独立的程序计数器。 ps:在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。如果线程执行的是Java方法，计数器值为正在执行的虚拟机字节码指令的地址；如果线程执行的是Native方法，计数器值为空。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域 虚拟机栈这个内存区域表示Java方法执行的内存模型：每个方法执行过程中都会创建一个用于存储局部变量表、操作数栈、动态链接、方法出口等信息的栈帧。递归为什么这么不受待见有很大的原因是其执行效率与虚拟机栈的深度挂钩，因为每次递归调用都对应一个栈帧在虚拟机入栈出栈的过程，深度越大，开销越大，效率越低。 局部变量表存放了编译期已知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。在编译期，局部变量表所需内存空间已完成分配，并在运行期间不会被改变。JVM规范中：如果请求的栈深度大于虚拟机所允许的深度会抛出StackOverflowError异常；如果虚拟机动态扩展时无法申请足够的内存会抛出OutOfMemoryError异常。 本地方法栈与虚拟机栈作用相似，区别在于虚拟机栈用于JVM执行Java方法（字节码），而本地方法栈用于JVM执行Native方法。Sun HotSpot虚拟机直接将这两部分合二为一了。 堆在面向对象程序设计中，对象尤为重要，因此Java内存模型中，堆内存也尤为重要，因为几乎所有的对象实例以及数组都要在堆中分配内存空间（少部分对象实例得益于JIT编译器与逃逸分析技术的发展可以在其他区域分配内存空间）。由于这部分内存是线程共享的，因此也会有令人头疼的并发线程安全问题。为了能够更好的分配内存或回收内存（分代收集），堆内存也可以根据对象实例的特点作进一步的划分，不管怎样，该区域存放的都是对象实例。 JVM规范中：如果堆中没有内存完成实例分配，且堆内存无法动态扩展，则会抛出OutOfMemoryError异常 方法区方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据，为线程共享区域。在HotSpot虚拟机中，方法区可以看成是GC分代收集中的永久代，因此HotSpot的垃圾收集器就可以像管理堆内存一样管理这部分内存区域；而对于其他的虚拟机来说是不存在永久代的，由于JVM规范并没有限制，因此不同的虚拟机对方法区的实现可以有不同的细节。虽然该区域数据比较少被回收——“永久代”，但不意味着永不回收，该区域的内存回收目标主要是针对常量池的回收和对类型的卸载，只是触发难度大、频率低。 由于使用永久代实现方法区会更容易遇到内存溢出问题，官方也有逐步采用Native Memory来实现方法区的规划，在目前的JDK1.7的HotSpot中，已经将原本放在永久代的字符串常量池移出。JVM规范中：当方法区无法满足内存分配需求时，将抛出OutOFMemoryError异常 运行时常量池属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这些信息位于Class文件中），同时也支持在运行期间往池中加入新的常量（String类的intern()方法） JVM规范中：当常量池受方法区内存限制而无法申请足够的内存时，将抛出OutOFMemoryError异常 直接内存关于内存问题，仅仅知道运行时数据区是不够的，还有一块经常用到的内存，称为直接内存（不属于JVM范畴）。当我们在设置JVM参数时，若忽略了直接内存的存在使得各个内存区域综合大于物理内存限制，也会抛出OutOFMemoryError异常 内存泄露与溢出 内存泄漏是指那些本应该回收（不再使用）的内存对象无法被系统回收的现象;内存溢出是指系统在为某段执行指令（程序）分配内存的时候，发现内存不足，抛出异常的现象。因此，内存泄露可导致内存溢出。关于更多，可移步科普：内存泄漏与内存溢出 在清楚了运行时数据区之后，我们有必要意识到，只要空间有限，都会有几率发生内存溢出的情况。在JVM规范的描述中，运行时数据区除了程序计数器之外都有可能发生OutOfMemoryError（OOM）异常，既然抛出的都是OOM异常，那么如何判断出具体是哪一个区域发生OOM异常呢？ 堆溢出（OutOfMemoryError）在Java内存模型中，堆用于存储对象实例，只要对象不断被创建并且GC Roots到对象之间路径可达（避免垃圾回收），则当超出最大堆容量限制就会抛出OOM异常。容易辨认的是，当堆内存发生溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会进一步提示“Java heap space”。通常的处理思路都是通过工具分析堆转储快照，进而确定是内存泄露还是内存溢出，再进一步调整源代码（处理内存泄露）或者设置JVM参数（处理内存溢出）。 虚拟机栈和本地方法栈溢出（StackOverflowError或OutOfMemoryError）在JVM虚拟机规范中，除了OOM（虚拟机在扩展栈时无法申请足够的内存空间）异常之外，还有StackOverflowError(线程请求的栈深度大于虚拟机所允许的最大深度)异常。书中作者做了一个实验，表明在单线程环境下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配时，都只抛出StackOverflowError异常。而创建多线程时，则会有可能抛出“java.lang.OutOfMemoryError:unable to create new native thread”，这个时候若不能减少线程数或者更换64位虚拟机（所限制内存容量比32位大），就只能减少最大堆（其他空间）和减少栈容量（自身空间）来换取更多线程。 方法区和运行时常量池溢出方法区用于存放Class的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当运行时产生大量的类时就会溢出，抛出java.lang.OutOfMemoryError：PermGen space异常。这样的场景经常在动态生成大量Class的应用中出现，如使用CGLib字节码增强和动态语言、以及大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGI的应用等。由于永久代（方法区）很少发生垃圾回收，因此得时刻注意永久代内存使用情况。 本机直接内存溢出由于本机直接内存并不属于JVM范畴，但是却也抛出OOM异常，因此当上述区域异常排除之后，可以检查是否因为本机直接内存不足而发生OOM。DirectMemory容量可以通过“-XX：MaxDirectMemorySize指定，默认与堆最大值一致”。 垃圾回收机制在了解相关内存区域的溢出现象之后，就应该意识到不能一直让一些没有用的“垃圾”一直占用着紧缺的内存资源，否则经常性的内存泄漏与溢出会严重影响着应用程序的性能与稳定性。关于内存方面，C++程序员的良好习惯之一就是时刻给不再使用的对象释放内存。好在如今垃圾收集技术（简称GC）已经相当成熟，在Java中内存回收已经被JVM给自动化了，Java开发者在程序开发中不用过多的关注内存问题，但是当需要排查各种内存溢出、泄漏问题时，又或者GC成为应用系统瓶颈时，就还是得具备对JVM内存回收进行必要监控和调节的能力。为此，就应该要对JVM的垃圾回收机制有一定的了解。 垃圾回收区域对于程序计数器、虚拟机栈、本地方法栈而言，当方法结束或者线程结束的时候，内存自然也随即被释放了，所以这些内存区域并不需要垃圾回收器过多的操心，而堆由于会在程序运行过程中不断创建对象，占用空间不断增大，因此是垃圾收集器主要起作用的区域。至于方法区，偶尔也会发生垃圾回收。 堆的回收在对堆进行垃圾回收之前有一个很重要的步骤就是判断堆中对象哪些是无用对象（垃圾）： 引用计数法给对象设置一个引用计数器，当每次对象被引用时计数器+1，引用失效-1，当计数器值为0则可判定该对象为垃圾。可以认为引用计数法是一种比较简洁高效的方法，然而并不能正确处理对象间相互引用的情况 可达性分析法在Java中是通过可达性分析算法来判断的（涉及到图论的相关知识），以一系列称为“GC Roots”的对象作为起点，对堆中存在引用的对象进行图的遍历（深度优先或广度优先），经过的路径称为引用链。若一个对象往GCRoots不与任何引用链相连（不可达），则视为待回收的垃圾。这样即使存在对象间相互引用的情况，只要与GCRoots不可达，则都会被正确处理。 在java中可作为GCRoots的对象主要有：虚拟机栈（栈帧中的本地变量表）中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；本地方法栈中JNI（即Native方法）引用的对象。其实不可达的对象，也是可以自救的，只要在由虚拟机自动建立的低优先级的Finalizer线程执行对象的finalize()方法时，在finalize()方法中恢复与引用链的关联即可。需要注意的是任何一个对象的finalize()方法都只会被系统自动调用一次。不过这种方法不被作者推崇，因为try-finally能够有更好的表现。 在JDK1.2之后，引用又多了几个种类，以适应“当还有剩余内存空间时暂不回收无用对象”的应用场景：（1）强引用，如Object obj = new Object()，只要存在强引用，垃圾收集器就不会回收被引用对象（2）软引用，此类被引用的对象，在系统将要发生内存溢出异常之前，才会被列进回收范围之中进行二次回收，JDK1.2之后的实现类为SoftReference（3）弱引用，此类被引用的对象，无论内存是否足够都会被回收，JDK1.2之后的实现类为WeakReference（4）虚引用，最弱的引用关系，对被引用的对象完全没有影响，只是在这个对象被回收时能够收到一个系统通知，JDK1.2之后的实现类为PhaantomReference 方法区的回收方法区的垃圾收集主要是废弃常量和无用类，其中常量池的回收与堆回收类似，只要这个常量没有被使用，必要时就会被清理。而判断一个类是否为“无用类”则条件相对苛刻，需要满足：（1）该类所有的实例已经被回收，堆中不再存在该类实例（2）加载该类的ClassLoader已经被回收（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法满足条件的才可以被回收，但是对于HotSpot虚拟机，实际是否被回收还需要设置虚拟机的相关参数 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证该区域不会溢出 垃圾收集算法上面描述了如何判定一个对象为需要被回收的无用对象，现在介绍下常见收集算法的算法思想 标记—清除算法最基础的收集算法，分为标记与清除两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收。这个算法的不足之处在于：（1）效率问题，标记清除两个阶段的效率都不高（2）空间碎片问题，标记清除后会产生大量不连续的内存碎片，可能会导致接下来程序运行过程中需要分配较大对象时由于无法找到足够大的连续内存而触发另一次垃圾收集 复制算法复制算法一定程度上提高了效率，通过将可用内存容量划分为两等份，每次使用其中之一，当空间用完时就将还存活的对象复制到另外一份中，然后把原来那份内存全部清理掉。虽然效率比标记清除算法高，但是牺牲了一半的内存空间，代价太高。不过针对空间浪费的问题，其实也是可以通过改变划分的区域比例来调整的。 标记—整理算法复制算法在对象存活率较高时就需要进行较多次数的复制操作，效率反而降低。标记-整理算法则提供了新的思路，分为标记与整理两个阶段：先标记出待回收的对象，然后让所有存活对象往一端移动，最后清理存活对象以外的内存。 分代收集算法由于堆中的对象众多，随着应用程序的运行，有些可能创建不久后就废弃掉了，而有些则一直存活着。为了提高收集效率，虚拟机采用了分代收集的思想来管理内存。根据对象的存活周期，将内存划分为新生代和老年代。在新生代中发生的垃圾收集称为MinorGC，由于新生代中的对象存活率低，因此可以采用复制算法，耗费较低复制成本就可以完成收集。在老年代发生的垃圾收集称为MajorGC/FullGC，由于对象存活率高，因此常采用“标记-清除”或“标记-整理算法”。关于对象在不同年代的划分稍后还有叙述。 垃圾收集器垃圾收集算法只是一些垃圾回收的指导，垃圾回收的具体实现还是得看垃圾收集器。在HotSpot虚拟机中有着许多不同的垃圾收集器实现，不同的收集器对应着各自适用的场景 上面有7中收集器，分为两块，上面为新生代收集器，下面是老年代收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用 Serial收集器Serial收集器是最基础，最简单的单线程收集器，采取复制算法，它在进行垃圾收集时，必须暂停所有的工作线程，直到收集结束。也就意味着，只要它一工作，其他线程完全不能动，这样看来简直就是一个万恶的存在啊，只能乖乖等它完成工作才可以进行别的操作。但是它也是简单而高效的，因为没有线程交互的开销，在不需要做其他工作时候单纯拿来做垃圾收集还是不错的选择。 ParNew收集器除了使用多线程进行收集之外，ParNew收集器与Serial收集器没有太多的区别，也是采取复制算法等。虽然支持多个GC线程并行工作，但是其他线程仍然需要等待GC完成，而且由于线程交互的开销使得效率并不如Serial收集器，不过当CPU非常多的时候，还是可以充分利用系统资源的。 Parallel Scavenge收集器和ParNew一样，Parallel Scavenge收集器也是一个并行的多线程收集器，也采用复制算法。区别在于，Parallel Scavenge是一个“吞吐量优先”的收集器（吞吐量=运行用户代码时间/CPU总消耗时间（运行用户代码时间+垃圾收集时间）），也就是说，吞吐量高代表着高效利用CPU的时间，适合在后台运算不需要太多交互的任务。此外，Parallel Scavenge可以通过设置参数来使用GC自适应调节策略，使虚拟机根据当前系统运行状况收集性能信息并动态调整以提供最大的吞吐量，自主优化。 Serial Old收集器Serial收集器的老年代版本，同样是单线程收集器，只是采取标记-整理算法 Parallel Old收集器Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法” CMS收集器上述收集器，在GC运行时或多或少都会引起其他工作线程的停顿，而Concurrent Mark Sweep（CMS）收集器，则是一种以获取最短回收停顿时间为目标的收集器。由于可以减少停顿时间，提高服务的响应速度，因此CMS得到了广泛的运用。CMS收集器采用标记-清除算法，运行过程主要分为四步：初始标记、并发标记、重新标记、并发清除。其中初始标记和重新标记仍然需要停止其他线程，不过速度快，其余耗时的过程均可并发执行，因此是一款优秀的收集器。不过它也有缺点：对CPU资源非常敏感；无法标记并发清理阶段时产生的垃圾，直到下一次GC；由于基于标记-清除算法，会产生大量空间碎片 G1收集器G1是一款面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一，目前还很少投入实际运用它具备以下特点：并行与并发——支持GC并行执行，而且与工作线程并发执行分代收集——可独立工作于新生代和老年代而不需要搭配，且可以采用不同方式管理新生代与老年代对象空间整合——基于复制算法与标记-整理算法，不会产生内存碎片可预测的停顿——可控制停顿时间与其他收集器不同，G1虽然保留有分代的概念，但是管理堆时是将堆划分为多个大小相等的独立区域Region，并且记录回收每一个Region的性价比，当需要回收时则回收性价比最大的Region，从而提高规定时间内的收集效率。不过这种方式存在着很大的问题就是Region间对象的相互引用，可以通过引入一个值来记录这些引用，从而避免全堆扫描。与CMS类似，G1工作时也分为几个步骤：初始标记、并发标记、最终标记、以及筛选回收。 垃圾收集小结至此，对垃圾收集器体系有了进一步的了解，知道了垃圾收集主要发生在堆中，而且采用分代收集的思想，并了解了HotSpot虚拟机的常见垃圾收集器实现 堆内存的分代管理由于绝大多数虚拟机都采用分代收集的思想来管理堆内存，那么也就意味着内存分配也要采用分代的思想以契合垃圾回收机制，那么怎样判定对象应该分配到哪一代呢？这就是自动内存管理的另一大主题——内存分配策略 一般情况下，虚拟机将堆内存分为新生代、老年代，HotSpot虚拟机也将方法区归入分代的思想中，称为永久代。其中，新生代又分为Eden区和Survivor区 正常分配流程大多数情况下，对象优先在Eden区中分配，当Eden区空间不足时，则会触发MinorGC，Eden存活对象在Survivor空间允许的情况下，则会进入Survivor区并且年龄计数器+1。此后存活的Eden对象和其中一个Survivor区对象在垃圾收集器复制算法作用下在两个Survivor区之间来回切换，并且每在一次MinorGC存活下来，年龄计数器就+1，到一定岁数之后（默认15），对象就会进入老年代。 提前衰老大对象直接进入老年代大对象是指需要大量连续内存空间的对象，例如很长的字符串以及数组。将大对象分配到新生代是很不明智的做法，首先因为该对象每存活一次，就需要耗费成本找一大串连续空间进行复制，找不到时就会触发GC；其次剩余空间容量少，也容易导致空间不足而频繁GC。因此一些虚拟机可通过设置参数来让大对象超过指定大小时直接进入老年代。 动态调整如果Survivor空间中相同年龄的所有对象加起来大小大于该空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。 空间分配担保机制考虑这样一种情况，在触发一次MinorGC后，Eden和其中一个Survivor中的对象全部存活，这时往另外一个Survivor复制的时候发生空间不足的情况怎么办呢？这时就需要老年代进行分配担保，容纳Survivor放不下的对象。当然，老年代进行空间分配担保也需要足够空间才能完成的，然而在实际完成回收之前并不能确定所需要的空间，因此可以取之前每次回收进入老年代对象的总大小平均值作为过往的经验参考来与老年代剩余空间比较，以确定是否进行FullGC。 在JDK6 Update24之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行MinorGC，否则将进行FullGC。 小结兜兜转转，终于写完了这篇笔记，特别感谢周志明的《深入理解Java虚拟机》一书，详尽的介绍了很多关于JVM的知识点。这篇博客也主要是对书中内容结合思考后的一些简单提炼。归结一下，个人觉得JVM的自动内存管理机制所主要解决的问题，就是程序运行时内存资源如何协调的问题。首先，JVM对内存区域进行了划分，分类存储管理类属性、对象、方法变量等资源，并通过分代的思想管理变换莫测的堆内存，实现垃圾收集器回收内存以避免内存泄露与溢出等影响着程序性能与稳定的异常。当然通篇都只是理论，重要的还是如何根据理论利用工具进行调优实践，书中有个Eclipse调优案例，是一个很好的补充，但是这种实操型技能还是需要切身实际的操作一遍，有时间会另外写一篇调优实践，貌似对Tomcat进行调优是个不错的选择。]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Comparator的运用|把数组排成最小的数]]></title>
    <url>%2F2017%2F06%2F21%2FJava%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[刚好刷到一道笔试题，描述如下： 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 如果排列出所有的结果，再从中选择最小的组合，这样的做法在数据量规模很大的前提下，排列的结果集为n(n-1)(n-2)……无疑是很不切合实际的做法。根据数字的特征，很容易就可以发现要使拼接出的数字最小，只要预先排序（数字a，b；ab&gt;ba？b,a:a,b），再将排序后的结果集拼接起来就是答案。由于对排序算法比较熟悉，所以第一时间想到的就是快排，冒泡等常见的排序算法，但是这里的重点除了排序之外，还有排序所使用的比较规则。因此又联想到一种较为常见的排序方法，就是使用Java集合以及comparator比较器。而且由于在某一次面试中，被面试官问道如何对集合中的对象排序时还不是很熟悉自定义比较器comparator的使用，因此特意总结下关于这方面的知识点。 题目解答代码12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(numbers==null||numbers.length==0)&#123; return &quot;&quot;; &#125; //将数组存入List中 int length = numbers.length; for(int i = 0;i&lt;length;i++)&#123; list.add(numbers[i]); &#125; //通过匿名内部类实现自定义Comparator //对List使用自定义规则排序 Collections.sort(list, new Comparator&lt;Integer&gt;()&#123; //实现自定义Comparator public int compare(Integer str1,Integer str2)&#123; String s1=str1+&quot;&quot;+str2; String s2=str2+&quot;&quot;+str1; //根据字典序比较 return s1.compareTo(s2); &#125; &#125;); //拼接排序结果集 StringBuffer sb = new StringBuffer(); for(int s:list)&#123; sb.append(s); &#125; return sb.toString(); &#125;&#125; Comparator自定义排序在实现代码中，通过匿名内部类方式创建了一个比较器Comparator。对于位于java.util包中的Comparator接口，官方文档中的解释是： 为强制对某些集合中的对象进行整体排序提供对象间相互比较功能。比较器可以传递到如Collections.sort或Arrays.sort等sort方法中对排序行为进行精确控制。比较器也可以用于控制特定数据结构（如sorted sets或sorted maps）的元素顺序或者给没有自然顺序的集合对象提供排序功能。 自然顺序：如数字，字符等可直接比较大小的元素顺序 也就是说，当我们想要给对象集合根据自己的意愿来排序的时候，就可以通过重写compare方法来实现比较规则，并传入sort方法中进行整体排序。在JDK1.8之前Comparator只有两个方法123456public interface Comparator&lt;T&gt; &#123; public int compare(T t1, T t2); public boolean equals(Object object);&#125; 然而在JDK1.8中，又新增了很多方法，具体看官方API，这里关注compare以及equals方法。 compare传入两个对象t1,t2，并在函数体内定义比较规则若返回值&gt;0,则说明t1&gt;t2若返回值==0，则说明t1==t2若返回值&lt;0，则说明t1&lt;t2为了避免一些奇奇怪怪的情况如往TreeSet添加元素失败等，最好在实现比较规则时让compare(t1,t2)==0的布尔值与t1.equals(t2)的布尔值相等 equals当且仅当object也是一个比较器并且实现同样的比较规则时返回true。当创建一个类实现该接口时，该方法不是必须要实现的，因为每一个Oject都有equals方法 当然，如果需要比较规则可复用，我们就不能写成匿名内部类的形式了，而是需要定义一个实现Comparator接口的类，并且在实现compare方法之后将其传入sort方法中，同时我们还可以创建许多比较规则类，根据不同的情况选用不同的规则，这种编码技巧就运用到了策略模式的思想。 策略模式的运用介绍：算法的封装与切换正如上述实现代码所体现的，集合中的元素与具体的排序规则分离这样一种数据与算法分离思想，就是策略模式的主要思想。 在策略模式中，我们可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里，每一个封装算法的类我们都可以称之为一种策略(Strategy)，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类。 结构图与典型代码实现结构图： 代码实现：1234567891011121314151617181920212223abstract class AbstractStrategy &#123; public abstract void algorithm(); //声明抽象算法 &#125;class ConcreteStrategyA extends AbstractStrategy &#123; //算法的具体实现 public void algorithm() &#123; //算法A &#125; &#125;class Context &#123; private AbstractStrategy strategy; //维持一个对抽象策略类的引用 public void setStrategy(AbstractStrategy strategy) &#123; this.strategy= strategy; &#125; //调用策略类中的算法 public void algorithm() &#123; strategy.algorithm(); &#125; &#125; 运用在集合排序与比较器关系中，集合就作为策略的使用类而比较器就作为策略类，实现了算法的定义与使用环境分离。关于策略模式，更多请阅读：策略模式-Strategy Pattern Comparable自然排序在集合的排序中，除了使用自定义比较器之外，还可以通过使数据类实现java.lang.Comparable接口来实现自然排序，接口中唯一的campareTo方法称为自然比较方法。 compareTo(Object obj)传入一个对象，函数体内定义比较规则：若返回值&gt;0，则说明this&gt;obj若返回值==0,则说明this==obj若返回值&lt;0，则说明this&lt;obj和Comparator一样，为了避免一些奇奇怪怪的情况，最好在实现比较规则时让this.compareTo(obj)==0的布尔值与t1.equals(t2)的布尔值相等 因此，当类实现了Comparable接口后，就说明该类中的对象支持排序，并且可以直接使用Collections.sort（和 Arrays.sort）根据compareTo的比较逻辑进行自动排序；又或者用作sorted set或sorted map中的元素且无需指定比较器。关于更多可直接看官方API sort方法的排序算法在清楚了比较规则之后，我们还需要弄清楚一个问题，就是Collections.sort方法以及Arrays.sort方法是如何根据比较规则来实现排序的。查看Collections的源码，1234@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;) public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c); &#125; 发现其中的sort方法只是调用List的sort方法，那也就是说，真正的排序逻辑在List的实现类中，以ArrayList为例，其源码中sort部分：12345678910@Override @SuppressWarnings(&quot;unchecked&quot;) public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; 其中modCount主要在多线程环境下需要使用，防止一个线程正在迭代遍历，另一个线程修改了这个列表的结构。更多。可见，List的sort方法也是调用了Arrays.sort，接下来看相关源码：1234567891011public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125; &#125; 因此可以得出结论，在JDK8中运用比较器的Arrays.sort方法主要运用了两种排序算法,归并排序以及结合归并排序和插入排序的TimSort。相关排序算法原理就暂不说明了，建议了解大体算法思想后直接读源码。 小结本文先从一道简单的笔试题出发，了解Comparator在排序中的相关使用，进而从中熟悉策略模式，并了解另外一种比较技巧——实现Comparable，最后了解JDK中的排序算法。关于Comparator与Comparable的区别，我的理解是：Comparator只是一个比较器，对象集合需要引入该比较器才可以相互比较，属于外部范畴；而Comparable是一种功能，实现该接口的对象集合中的对象都具有可比较的特性，属于内部范畴。举个栗子，人本来不能飞，但是可以通过坐飞机或者坐飞船来实现飞行的梦想（Comparator）；而有些人基因变异，长出了翅膀，因此并不需要辅助工具，也能够飞（Comparable）。]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记|SQL性能优化]]></title>
    <url>%2F2017%2F06%2F14%2F%E7%AC%94%E8%AE%B0-SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前不久在图书馆借了一本《MySQL技术精粹》，现在快要归还了，打算做个笔记，主要内容为之前几乎没有接触过的SQL性能优化部分。因为一直在用MySQL，也写过不少SQL语句，可是自己平常写的小项目中数据量不会很大，也没有投入生产环境，因此对性能方面要求不高，然而在实际应用中，面对海量数据存储的应用，为了不让SQL执行的效率制约应用的效率，就不得不优化SQL了。对于后端开发者而言，有必要了解关于SQL优化的相关知识。 笔记MySQL Query Optimizer在MySQL中有个专门负责优化SELECT语句的优化器模块——Query Optimizer，能将客户端传送过来的查询语句，结合数据库系统收集的各种统计信息，为客户端的SQL进行查询优化（常量转化，无效内容删除，常量计算等等），最终得出执行计划。Query Optimizer的所有工作都基于QueryTree，其记录了完成一个Query所需要经历的步骤，每一步的数据来源以及处理方式等。因此，MySQL数据库能在一定程度上帮助我们开发者优化SELECT语句。 SQL优化查询语句基本思路优化更需要优化的查询先从对整个系统的影响来考虑，什么样的优化能给系统整体带来更大的受益，就是更需要优化的查询。例如高并发低消耗的查询就远比低并发高消耗的查询对系统影响大。假设A查询每分钟执行10000次，每次30个读写；B查每分钟执行100次，每次3000个读写。两个查询总操作数相同，但是在优化的时候，A查询读写减少5个，每分钟总操作数减少50000次；而B查询要达到同样的效果，却要减少500个读写。可见优化更需要优化的查询不仅实现难度低，而且带来的效果是可观的。 定位优化对象的性能瓶颈确定优化对象后，就要定位优化对象的性能瓶颈了，是读写问题呢？还是CPU耗损问题呢？是数据运算耗费资源呢？还是数据访问耗费太多的时间？使用PROFILING能很清楚的找出一个查询瓶颈所在。 明确优化目标当找到性能瓶颈之后，就要制定优化目标。先搞清楚数据库目前的状态，确定数据库所能承受的最大压力然后清楚数据库中与该查询相关的数据库对象信息，确定查询消耗资源的情况接着了解查询实现的功能，根据功能点在系统中的地位得出可以占用的系统资源比例。最后得出查询的性能范围，也是优化目标范围。 充分使用EXPLAIN和PROFILE工具对SQL语句进行分析确定优化目标后，开始实际优化操作。借助EXPLAIN工具查看查询的执行计划，并不断调整查询语句，以期达到优化目标，最后得出优化的查询语句 利用EXPLAIN分析查询语句解释： IDID列中的数据为一组数字，表示执行select语句的顺序ID值相同时，执行顺序由上至下ID值越大优先级越高，越先被执行 SELECT_TYPESIMPLE：不包含子查询或是UNION操作的查询PRIMARY：查询中如果包含任何子查询，那么最外层的查询则被标记为PRIMARYSUBQUERY：SELECT 列表中的子查询DEPENDENT SUBQUERY：被别的查询所依赖的子查询UNION：union操作的第二个或是之后的查询的值为unionDEPENDENT UNION：当union作为子查询时，第二或者是第二个后的查询的值UNION RESULT：union产生的结果集DERIVED：出现在from子句中的子查询 TABLE输出数据行所在的表的名称或别名：由ID为M,N查询union产生的结果集： unionM,N由ID为N的查询产生的结果: derivedN/subqueryN PARTITIONS对于分区表，显示查询的分区ID对于非分区表，显示为NULL TYPE（类型性能是依次降低的）system，这是const连接类型的一个特例，当查询的表只有一行时使用。const，表中有且只有一个匹配的行时使用，如对主键或是唯一索引的查询，这是效率最高的联接方式。eq_ref，唯一索引或者是主键索引查找，对于每个索引键，表中只有一条记录与之匹配ref，非唯一索引查找，返回匹配某个单独值的所有行。ref_or_null，类似于ref类型的查询，但是附加了对NULL值列的查询。index_merge，该联接类型表示使用了索引合并优化方法。range，索引范围扫描，常见于between、&gt;、&lt;、这样的查询条件。index，full index scan 全索引扫描，同ALL的区别是，遍历的是索引树。all，full table scan 全表扫描，这是效率最差的联接方式。 EXTRAdistinct，优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作not exists，使用not exists来优化查询using filesort，使用额外操作进行排序，通常会出现在order by 或者 group by查询中。using index，使用了覆盖索引进行查询。using temporary，需要使用临时表来处理查询，常见于排序，子查询，分组查询using where，需要在mysql服务器层使用where条件来过滤数据。select tables optimized away，直接通过索引来获得数据，不用访问表。 POSSIBLE_KEYS指出mysql能使用那些索引来优化查询，查询列所涉及到的列上的索引都会被列出，但不一定会被使用 KEYS查询优化器优化查询实际所使用的索引，如果查询过程中没有用到索引，则会显示为NULL，此处的值也可能不出现在POSSIBLE_KEYS，则说明，使用了覆盖索引。 KEY_LEN表示索引字段的最大可能长度。此值的长度有字段定义计算而来，并非数据的实际长度。 REF表示那些列或常量被用于查找索引列上的值 ROWS表示mysql通过索引统计的信息，估算出的所需读取的行数。是一个不十分准确的值。 FILTERED表示反悔结果的行数占需读取行数的百分比，越大越好，也并不十分准确。 利用Profiling分析查询语句通过该工具可以获取查询在整个过程中多种资源的消耗情况，例如内存消耗、I/O消耗和CPU消耗等语法:SHOW PROFILE [type[,type]…][FOR QUERY n][LIMIT row_count [OFFSET offset]] 其中type取值有： ALL：显示所有信息 BLOCK IO：显示输入输出操作阻塞的数量 CONTEXT SWITCHES：显示自动或非自动CONTEXT SWITCHES的数量 CPU：显示系统和CPU使用的时间 IPC：显示消息发送和接收的数量 MEMORY：内存的信息 PAGE FAULTS：显示主要的PAGE FAULTS数量 SOURCE：显示函数的名称，并且显示函数所在文件的名字和行数 SWAPS：显示SWAP数量 使用步骤：1.查询profiling是否开启1select @@profiling; 2.开启profiling1SET profiling = 1; 3.执行查询语句4.查看Profiling情况，得出查询语句在Profiling中的ID1show profiles; 5.根据ID分析该查询资源的消耗情况1show profile [type] for query &quot;ID&quot; 合理地使用索引1.使用LIKE关键字的查询语句，匹配字符串的第一个字符不能为“%”，否则索引失效2.使用多列索引的查询语句，查询条件需要有这些字段中的第一个字段，否则索引失效3.使用OR关键字的查询语句，若查询条件只有OR关键字，则OR前后的两个条件中的列都必须有索引，否则索引失效 不同类型SQL语句优化方法优化INSERT语句1.同时插入多行数据，减少客户端与数据库服务器之间的连接和关闭等操作2.对于MyISAM表，可以使用INSERT DELAYED语句提升执行速度，不过数据不会立即插入到表，而是在内存中等待，空闲时插入，若系统崩溃将会丢失数据3.锁定表 优化ORDER BY语句 采用索引进行优化 1.对ORDER BY + LIMIT组合的索引优化1SELECT [column1] …… FROM [TABLE] ORDER BY[sort] LIMIT[offset],[LIMIT]; 该语句优化只需要在[sort]上建立索引 2.对WHERE+ORDER BY+LIMIT组合的索引优化1SELECT [column1] …… FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort] LIMIT[offset],[LIMIT]; 这时，可以建立联合索引(columnX,sort) 3.不要对WHERE和ORDER BY的选项使用表达式或函数 不应该使用索引的情况 1.order by 的字段混合使用asc和desc2.where字句使用的字段和order by 的字段不一样3.对不同的关键字使用order by 排序 优化GROUP BY语句通过指定ORDER BY NULL可以禁止自动排序，从而节省损耗，优化GROUP BY语句 优化嵌套查询使用连接查询 JOIN 代替子查询，避免在内存中创建临时表 优化OR条件对OR的每个条件列添加索引 优化插入记录的速度插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等等 MyISAM表1.禁用索引2.禁用唯一性检查3.一条INSERT语句插入多条记录4.使用LOAD命令 InnoDB表1.禁用唯一性检查2.禁用外键检查3.禁止自动提交 优化数据库结构1.对多字段的表进行拆分，冷热分离；查询时使用联合查询2.对经常联合查询的表建立中间表3.增加冗余字段，减少连接操作 分析表、检查表和优化表1.分析表ANALYZE TABLE分析关键字的分布2.检查表CHECK TABLE检查表是否存在错误3.优化表OPTIMIZE TABLE消除删除或者更新造成的空间浪费 小结本文主要记录了SQL优化的基本思路，使用EXPLAIN与Profiling进行性能分析要点，关于合理添加索引的建议；以及常用SQL语句的优化方法和数据库结构的优化方法。 更多MYSQL性能优化的最佳20+条经验数据库性能优化之SQL语句优化1]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaI/O体系及当中设计模式的运用]]></title>
    <url>%2F2017%2F06%2F12%2FJavaI-O%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在朋友的推荐下，机缘巧合的发现了一个挺不错的知乎专栏进击的Java新人，觉得作者对一些Java概念与运用的理解很透彻，也通俗易懂，对我的Java学习很有帮助。看到装饰器模式与适配器模式那一章节的时候，还结合了JavaI/O流去讲解，给我回顾JavaI/O流提供了新的思路。于是稍微总结了一下JavaIO流，以及其中运用到的设计模式。 设计模式先了解下在JavaIO中用到的适配器模式与装饰模式 适配器模式——协调互不兼容的结构介绍适配器模式，属于结构型模式之一，用于协调互不兼容的结构。在生活中，我们常常会碰到这样的情况，要给手机充电，得先找一个充电器来做电压的适配，否则就会烧掉。因此，适配器模式，就是在不改变现有对象结构的前提下，从中引入一个称为适配器的组件来协调双方，以相互支持。在手机，电源，充电器的关系中，充电器则作为适配器，毕竟我们不能更改手机工作电压和家庭标准电压嘛。在软件开发过程中，同样会有各种互不兼容的接口和类库，我们就可以从中引入一个适配器，来使这些不兼容对象一起运作。 在适配器模式中，我们通过增加一个新的适配器类来将一个接口转换为客户希望的另一个接口以解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高 对象适配器模式结构图 在上述结构图中，客户Client需要的是一个Target接口实现一个request()方法，然而现在只有Adaptee接口specificRequest()方法可以使用，因此需要一个适配器Adapter，作为转换器对Adaptee和Target进行适配，维护一个Adaptee对象，进而可以在适配器中调用该对象的方法。 结构图代码实现：1234567891011class Adapter extends Target &#123; private Adaptee adaptee; //维持一个对适配者对象的引用 public Adapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; public void request() &#123; adaptee.specificRequest(); //转发调用 &#125; &#125; 仔细想想，我们能否在一个适配器里面适配多个适配者呢？当然可以，只需要在适配器里面维护多一个适配者对象引用就好了。也就相当于我们在充电器里面添加了一个高电压的插件，现在不仅可以选择充手机，还可以选择为大型电器持续供电了。 ReadMore适配器模式-Adapter Pattern 装饰模式——扩展系统的功能介绍装饰模式，结构型设计模式之一，用于扩展系统的功能。作为技术控，有时候我们会经常自己升级电脑，给自己的电脑加固态什么的，这个时候，其实就是装饰模式的体现，在不改变一个对象本身功能的基础上给对象添加额外的新行为。而且装饰模式是一种比继承更好的技术，使用对象之间的关联关系取代类之间的继承关系，比继承更为灵活。 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。 其实也非常好理解，就是可以动态为对象增加额外能力嘛。 装饰模式结构图 在装饰模式中，为了让系统具有更好的灵活性和可扩展性，通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类.而且，由于具体构件与抽象装饰类都实现相同的抽象构件，因此对于客户端而言，装饰前后的构件是透明的，客户端察觉不出差别（装饰前是Component，装饰后仍然是Component），这种情况下我们还可以对已经装饰过的对象多次进行装饰。 代码实现：抽象装饰类：123456789101112131415class Decorator implements Component&#123; //维持一个对抽象构件对象的引用 private Component component; //注入一个抽象构件类型的对象 public Decorator(Component component)&#123; this.component=component; &#125; public void operation()&#123; //调用原有业务方法 component.operation(); &#125;&#125; 具体装饰类：12345678910111213141516class ConcreteDecorator extends Decorator&#123; public ConcreteDecorator(Component component)&#123; super(component); &#125; public void operation()&#123; super.operation(); //调用原有业务方法 addedBehavior(); //调用新增业务方法 &#125; //新增业务方法 public void addedBehavior()&#123; …… &#125;&#125; ReadMore装饰模式-Decorator Pattern 小结在大致了解适配器模式与装饰模式后，我们知道适配器模式常用于协调不兼容的接口而装饰模式用于扩展功能。接下来总结Java I/O流 Java I/O流流的概念 数据流是一串连续不断的数据的集合，就象水管里的水流，在水管的一端一点一点地供水，而在水管的另一端看到的是一股连续不断的水流。数据写入程序可以是一段、一段地向数据流管道中写入数据，这些数据段会按先后顺序形成一个长的数据流。对数据读取程序来说，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，再读取后面的数据（不能随机读取）。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。 概括一下，流就是有始有终、按序交付的数据序列。实际上，流对我们屏蔽了实际I/O设备处理数据的细节。 基于字节的流：输入流InputStream与输出流OutputStreamJava类库的设计者从一开始，就限定了与输入有关的类都继承自InputStream以及与输出有关的所有类都继承自OutputStream，因此可以说Java复杂的IO流其实都是InputStream和OutputStream的变体。 在JDK源码中，我们可以发现InputStream的定义为:1public abstract class InputStream implements Closeable 所以，InputStream是实现了Closeable的抽象类，需要依靠子类才能实现功能。其中，Closeable接口规定了close()方法，也就是说，所有的输入流（输出流）在使用完毕后都是需要关闭的。 按照数据输入来源的不同，继承于InputStream的子类又可以分为：1.ByteArrayInputStream——内存缓冲区作为来源2.FileInputStream——文件作为来源3.StringBufferInputStream——String作为来源4.PipedInputStream——与PipedOutputStream一起主要用于多线程环境下，实现“管道化”的概念5.SequenceInputStream——将多个InputStream转化为单一InputStream6.ObjectInputStream——与ObjectOutputStream一起主要用于对象的序列化 与InputStream相对应，OutputStream也是抽象类，继承于OutputStream的子类也可以根据输出目标分为：1.ByteArrayOutputStream——内存缓冲区作为目标2.FileOutputStream——文件作为目标3.PipedOutputStream——与PipedInputStream一起主要用于多线程环境下，实现“管道化”的概念4.ObjectOutputStream——与ObjectInputStream一起主要用于对象的序列化 简而言之：InputStream与OutputStream就是以字节的方式，将数据从来源写到目标的IO工作流。 装饰模式的应用作为抽象类的InputStream与OutputStream，其实现子类不仅包括上述提及的具体构件，还包括具有装饰功能的抽象装饰类FilterInputStream与FilterOutputStream。为了扩展多种不同的功能，如是否缓冲，是否保留所读过的行等等，JavaIO运用了装饰模式对基础InputStream(OutputStream)进行了扩展根据所需功能的不同，FilterInputStream又可以分为：1.DataInputStream——可以按照可移植方式从流中读取基本数据类型（int,char,long等）2.BufferedInputStream——使用缓冲区3.LineNumberInputStream——跟踪输入流中的行号4.PushBackInputStream——具有“能弹出一个字节的缓冲区”，用于回退读到的最后一个字节 FilterOutputStream又可以分为：1.DataOutputStream——可以按照可移植方式向流中写入基本数据类型（int,char,long等）2.PrintStream——可以产生格式化输出3.BufferedOutputStream——使用缓冲区 通过装饰模式，在FilterInputStream(FilterOutputStream)对象的构造器中传入InputStream(OutputStream)子类对象，我们就可以为其扩展相应的功能，常用的是Buffered缓冲功能所以我们会经常看到：1BufferedInputStream bi = new BufferedInputStream(new FileInputStream(File file)); 适配器模式的运用——基于字符的流：输入流Reader和输出流Writer编码问题由来已久，基于字节的InputStream和OutputStream能够很好地处理8位的ASCII字符，但是并不能很好地处理16位的国际化字符Unicode编码，而且Java中的char类型也是16位的，也就是说，Java必须提供一种能够Unicode字符的IO流。我们已经有了基于字节的InputStream与OutputStream，为了可以得到基于字符的Reader和Writer，那么只需要用上适配器模式，添加一个适配器类就可以了。而且通过适配器模式，我们也可以很方便的为InputStream/OutputStream添加多种编码字符格式支持 在IO中，这个适配器就是InputStreamReader和OutputStreamWriter，可以将InputStream/OutputStream转化为对应的Reader/Writer根据适配器模式图，我们不难理解三者的关系。在JDK8源码中，InputStreamReader的定义及相关构造函数：12345678910111213public class InputStreamReader extends Reader&#123; //Creates an InputStreamReader that uses the default charset. public InputStreamReader(InputStream in)&#123;&#125; //Creates an InputStreamReader that uses the named charset. public InputStreamReader(InputStream in, String charsetName)&#123;&#125; //Creates an InputStreamReader that uses the given charset. public InputStreamReader(InputStream in, Charset cs) //Creates an InputStreamReader that uses the given charset decoder. public InputStreamReader(InputStream in, CharsetDecoder dec)&#125; 因此InputStreamReader将InputStream以及特定编码字符集作为输入之后，就可以得到面向字符IO操作的Reader(Writer)了。既然InputStream和OutputStream有众多根据来源去向不同而不同的实现类，以及运用装饰模式的相关类，那么对应的Reader和Writer也会有相应的分类,如BufferedReader、PrintWriter等等。只不过类继承关系会稍有区别。 小结让我们顺着适配器模式的思路，回过头来看下FileInputStream，是不是也可以认为是一个适配器呢——将处理File的接口，转换为处理InputStream的接口。举一反三，根据适配器模式，我们就已经可以掌握绝大多数基本InputStream/OutputStream/Writer/Reader了；根据装饰模式，我们就可以掌握绝大多数具有扩展功能的InputStream/OutputStream/Writer/Reader了。剩下的问题，就是怎样从众多IO类库中选择并组合出合适IO流的问题了。再看一遍经常碰到的代码：1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 是否能一眼看出适配器模式与装饰器模式呢？不过在这种设计下，有时候我们只需要某一个单一的流，但是却为了创建这个流而创建了多个对象，虽然灵活但同时也增加了开销。 更多参考：Java I/O总结 更多除了IO流，Java IO类库还包括更多的内容，大体上JavaIO类库（本文为java.io包）的内容还可以分为以下几块：1.文件工具类2.序列化与反序列化3.压缩4.NIO 文件工具类File在IO中经常要进行文件相关的IO，因此，我们就会很频繁的对文件或者文件目录进行操作，在JavaIO中就提供了File工具类方便我们进行文件目录的相关操作File API RandomAccessFile有时候我们会遇到一些大文件，而我们并不需要完整的将其读出来，而是只需要读取某一部分内容，如果使用传统的InputStream和OutputStream等从头开始读到尾的IO流，明显效率低下。这个时候，我们就可以使用支持随机访问文件内容的RandomAccessFile来实现我们的需求了。不过，RandomAccessFile的绝大多数功能，已经被JDK1.4的nio的”内存映射文件(memory-mapped files)”给取代了。更多参考Java RandomAccessFile用法 序列化与反序列化在JVM作用下，当对象不再被使用时，就会被回收。有时候，我们想要保存对象的状态信息，将其写到一个文本文件之类的地方存储，使得重新运行程序时，可以读取文本文件并重建该对象使得其状态与程序上次运行时相同，这时候就可以使用对象序列化技术。在JavaIO类库中，提供了一个接口Serializable，实现了该接口的对象会被转换成一个字节序列，并且能够在以后将这个字节序列完全恢复为原来的对象。 要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时只需调用writeObject()即可将对象序列化，并将其发送给OUtputStream。（对象序列化是基于字节的，因此使用InputStream/OUtputStream继承层次结构）要反序列化一个对象，需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()，最后获得一个Object引用，需要进行向下转型。 更多阅读：Java对象的序列化与反序列化深入分析Java的序列化与反序列化 压缩JavaIO类库中也有压缩类以支持读写压缩格式的数据流，需要注意的是，这些压缩类位于java.util.zip包中而不是java.io包中；而且由于这些类继承自FilterInputStream以及FilterOutputStream，这也就意味着这些压缩类是装饰类，在使用时直接包装InputStream/OutputStream对象即可JavaIO压缩流 NIO通过查看io包的源码，我们会发现一些nio的痕迹，实际上，在jdk1.4时就引入了nio以提高速度，旧的io包也使用nio重新实现了。Java NIO入门与详解 小结在本文中，先大致了解了两个设计模式：适配器模式，装饰模式，然后从设计模式的角度总结了JavaIO流；接着大致了解了IO类库（io包）中的文件工具类、序列化与反序列化、压缩、NIO等内容。不得不说IO的范围非常地广，不仅涉及磁盘IO，还有网络IO等，可以从非常多的角度去总结，一篇小文章是绝对不够的而且也只能是凤毛菱角的。最后引用深入分析JavaIO的工作机制一文中的原话做个总结： I/O 的核心问题要么是数据格式影响 I/O 操作，要么是传输方式影响 I/O 操作，也就是将什么样的数据写到什么地方的问题，I/O 只是人与机器或者机器与机器交互的手段，除了在它们能够完成这个交互功能外，我们关注的就是如何提高它的运行效率了，而数据格式和传输方式是影响效率最关键的因素了. 最后感谢下述内容的提供，让我得以站在巨人的肩膀上：《Java编程思想》进击的Java新人Java I/O总结深入分析JavaIO的工作机制]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深究多态，为什么说静态成员无多态特性]]></title>
    <url>%2F2017%2F06%2F07%2F%E6%B7%B1%E7%A9%B6%E5%A4%9A%E6%80%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E6%97%A0%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[这是之前发表于CSDN的一篇旧文，迁移至此 这是前不久做的一道关于静态成员与静态方法特性的题，真的不做下题都不知道自己的基础究竟是有多浅薄，当然这里指对多态的理解 先回顾下静态成员与静态变量吧，static关键字参考书籍《Java编程思想》参考博客Java中static作用及用法详解我们知道，作为面向对象设计的明星程序语言，Java中的一切皆对象，而且每个对象都有其类型（class），决定了该类型对象的外观与行为（成员变量与成员函数）。通常，当创建一个类的时候，只是描述对象的外观与行为，中看不中用；只有在对象被new出来之后，才会在堆中存储该Java对象，具有实际使用价值。换句话说，只有对象才有实际作用。然而有时候，我们想不创建对象，就可以直接访问类中某个成员或者调用某个成员方法，于是就有了static关键字。当声明一个成员是static时，就意味着该成员可以通过类名直接访问，不与任何对象实例关联，是属于类的，为所有对象实例共享。 关于static的修饰作用——成员变量、成员方法、代码块1.对成员变量的影响对于类中的non-static成员变量，每实例化一个对象，就会分配相应的存储空间，可以有很多份，并且互不影响而对于类中的static成员变量，由于是类的数据，在创建类的时候就已经分配了存储空间，只有一份，所有对象共享 2.对成员方法的影响对于类中的non-static成员方法，其隐式含有this关键字——在方法内部获取当前对象的引用；而static方法，没有this关键字。因此non-static成员方法因具有this可以访问当前对象中的所有变量（包括static变量）以及static方法而static方法就只能访问static变量而不能访问或调用non-static成员 3.对代码块的影响static代码块在类加载时就会自动执行，且只会执行一次 关于初始化静态初始化只在类首次加载的时候进行，而且是必要时刻（即首次生成该类的一个对象时或者首次访问静态数据时），此后不会再次被初始化 关于继承static方法内不能使用super关键字，类似于this，即不可以访问父类的non-static变量或调用父类的non-static方法。但是不妨碍子类访问父类的static变量或static方法。除此之外父类的static方法不允许被子类方法重写 常见static方法main方法，作为程序入口，需要独立于任何对象实例存在 关于构造方法是不是static方法的论证（仍有争议）来源于知乎@RednaxelaFX的回答知乎传送门其本人博客实例构造器是不是静态方法 简单说：从Java语言层面看，构造器不是静态方法。事实上规范专门规定了构造器不是方法。从JVM层面看，构造器属于特殊的初始化方法，但仍然不被归类为静态方法。无论从哪个层面看，构造器都是可以静态分派的（statically dispatched）。但要特别注意的是，并非所有可以静态分派的代码都是静态方法，这是规范里有定义的术语。无论从哪个层面看，构造器都要接收从调用方传入的隐藏this参数。Java的静态方法不需要接收该参数，而实例方法要接收该参数。这方面构造器更接近于可以静态分派的实例方法，例如私有实例方法。这就是为什么从构造器可以调用this上的实例方法。书中的Dog例子，确实当Dog被首次实例化或其静态方法/静态变量被首次访问时，会触发Dog类的初始化。但构造器在此并不可以归类到静态方法的一侧。事实上构造器并不能被单独调用，而必须用在new表达式里，此时触发类初始化的正是new，而不是对构造器的调用——new与构造器调用是两码事。 对static有一定了解之后，再来了解下多态特性一说到面向对象程序设计三大特性，马上就能反应过来是，封装、继承、多态，在这边文章中主要讲多态。 什么是多态特性主要体现在方法调用上，同一个方法根据其对象类型的不同而采取不同的方法行为。得益于继承，对象既可以作为自己本身的类型使用，也可以作为它的基类型使用（向上转型），因此对基类型对象起作用的方法就可以用于其所有的导出类对象中并因为导出类对象的不同而有不同的方法行为。1234567891011121314151617181920212223242526class Animals &#123; public void sound()&#123; System.out.println(&quot;动物叫声&quot;); &#125;&#125;class Dog extends Animals&#123; public void sound()&#123; System.out.println(&quot;汪汪汪&quot;); &#125;&#125;class Cat extends Animals&#123; public void sound()&#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125;public class Test2&#123; public static void animalsSound(Animals a)&#123; a.sound(); &#125; public static void main(String[] args) &#123; Animals dog = new Dog(); Animals cat = new Cat(); animalsSound(dog); animalsSound(cat); &#125;&#125; 运行结果： 如上述示例，对于animalsSound(Animals a)方法，虽然传入的是Animals类型的引用Dog与Cat实例，调用其sound()方法，但是却根据Dog与Cat类型的不同而有不同的sound()方法实现，这就是表现出来的多态特性 如何使用多态特性1.通过继承重写相应方法（如上述示例）2.通过实现接口 为什么要使用多态（多态的好处）整理自网络1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 如何判断是否呈现出多态（多态的存在前提）参考知乎问题中 @程序狗@Intopass@NightSilence的回答1.要有继承关系2.子类重写父类的方法3.父类引用指向子类实例 有些地方，把方法重载也列入了多态的一种呈现，但个人也认为这种归类不够妥当。因为，方法重载中的方法由于参数表的不同，本质上已经不是同一个方法了，而是多个方法。而多态的涵义，就是调用同一个方法但是却有不同的实现行为。进一步说，根据后面会提到的多态特性的实现机制——动态绑定，在运行的过程中确定对象的类型并调用相应的方法。方法重载由于方法本身就不一样，在编译的时候就可以确定调用哪个方法了，并不需要动态绑定，也就不属于多态。知乎Java的函数重载为什么采用静态绑定而且，oracle官方文档的介绍，也验证了上述三个条件是多态的存在前提。 ps:在网络上也有很多关于多态的表现，诸如 个人目前还是只认可子类型多态 为什么说静态成员无多态特性？其实，在分别弄清楚stiatc与多态的本质后，已经不难回答这个问题了。首先，要明确，static成员，不管是static变量还是static方法，都是属于类的，不与任何对象实例相关联，而多态最起码得要有多个对象的存在，从面向对象的角度就可以解释这个问题。其次，static方法不允许被重写，也就不存在动态绑定之类的一系列问题。 动态绑定以及实现机制参考博客Java动态绑定和多态参考博客Java高级-动态绑定实现机制 上述内容或多或少的提及了动态绑定的概念，现在我们进一步了解。由于子类重写父类的方法，方法都是一样的，只是对象所属类型不一样了，而对象是需要运行时才可以创建的，也就是说，编译器只有一个父类引用时是没有办法确定到底要方法调用哪一个方法主体。所以就只能通过在运行时根据对象的实际类型再进行方法调用与方法主体的绑定，也叫做动态绑定或运行时绑定。而在编译时就可以确定的叫做静态绑定或前期绑定（C语言就是这样的） 对于java当中的方法而言，除了final，static，private和构造方法是前期绑定外，其他的方法全部为动态绑定 现在我们可以知道，要实现动态绑定，就需要在对象中内置某种“类型信息”，以便在运行时确定对象的准确类型。看下Java对象在虚拟机中的内存模型 就可以知道，JVM在运行时通过一种特殊结构指针来查找方法表中的类型数据指针指向的类型数据，来确定对象的准确类型，进而准确调用方法主体。现在也清楚了，Java中的运行时类型识别RTTI的机制——在运行期间对类型进行检查的实现原理了。 后记上述总结是多方面查找资料、博客所得，真心觉得Google比百度好用多了，如有错误，欢迎指正，大家一起讨论学习，感谢]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一场校招准备分享的笔记与心得]]></title>
    <url>%2F2017%2F06%2F05%2F%E6%A0%A1%E6%8B%9B%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[离校招越来越近了，虽然说金九银十，但是很多一线互联网公司如BAT等基本都会提前开始校招，正所谓机会总是留给有准备的人，提早准备总不会吃亏。刚刚听完嘉宾刘朋在offer先生上关于《程序猿|互联网技术岗秋招全解》的分享，记录了一些笔记，也结合下自己在刚刚过去的暑期实习生招聘的经历，做一个小总结，对自己接下来的秋招也有一定的参考价值。 校招基本流程每家公司的校招时间和流程都不尽相同，有些周期很长，有些可能一周就结束了，不过大抵都遵循一些基本流程，技术岗的话一般都会有：网申、笔试、技术一面、技术二面（综合面）、HR面等。 网申情况网申是最繁杂的，不过也是踏入这家公司招聘的第一步。这个时候要填写查户口式的基本资料、校园经历、项目经历、奖项荣誉等等。建议备好一个txt文件，保存大文段的文本内容，需要填写网申资料的时候复制粘贴。 笔试情况互联网公司的笔试一般都是线上笔试，考察内容以数据结构与算法、编程语言相关、计算机网络、操作系统、计算机基础理论为主。题型主要以选择题、简单题、在线编程题等。建议笔试前就多刷题，查漏补缺，因为覆盖范围真的太广了，没有一定的基础积累还是很吃力的。 面试情况面试一般都会去公司总部或者指定地点进行，状况也会层出不穷，有的纯技术轰炸，有的聊聊技术就开始聊理想，有朋友还遇到面试官与岗位不匹配的情况。有些问题是根据简历来问的，有些是简历上没有的，很随缘。我目前遇到的大都全程技术轰炸，时间都是30分钟左右吧，毕竟还比较菜，跟那些能聊上一个小时的大神没得比。 小结在整场校招竞赛中，个人觉得信息渠道挺重要的。刚刚过去的暑期实习生招聘其实都是一些大厂，底下还有很多不错的二线三线公司呢，不管怎么样，有机会都要去试试，多一次面试就多一次历练。而且在秋招的时候，招聘需求肯定会比暑期实习生招聘需求大，也更加密集，才知道消息就已经网申截止的情况并不少见。所以得时刻留意一些招聘信息，注重校招时间安排，可以专门拿个东西记录招聘信息等。 刘朋分享的笔记：优秀程序猿简历的模样1.条理清晰：内容分点、简要概括2.信息密度大：与工作岗位无关的内容少写或不写3.项目经历丰富：按照STAR法则提炼核心内容4.有技术比赛获奖：加分项5.成绩优秀：在某种程度上能说明一些问题6.技术博客和github项目：能体现技术的积累7.综合素质体现：沟通能力，团队协作能力等 技术笔试准备1.数据结构和算法：多刷题，反复刷经典题、笔试真题而不是新题；多看算法书2.操作系统：看经典书3.计算机网络：重点TCP/IP协议栈以及HTTP，常问打开一个网页背后发生了什么4.编程语言：语言运用方面的知识点5.计算机理论基础：多刷题，多积累了 面试准备1.笔试与面试都是能力考查的形式，笔试知识在面试时一样会问，还是要多看经典书，刷真题2.有机会就去面试，多实战3.看面经4.问清楚面试官的问题再答题5.遇到不会的可以适当请求提示6.谈薪资时（HR面）让对方先提 STAR法则之前面试的时候，在被要求介绍项目的时候，关注点都过多的放在了做过什么上，总感觉没能讲到点子上，表述不够清晰。机缘巧合之下，知道了STAR法则。才了解原来很多职场人士都推荐在面试时使用STAR法则来有逻辑地陈述过往经历。而且简历上也可以很好的运用STAR法则来描述项目经验。 阿里巴巴HR推荐的简历法则用对STAR法则，不止能面好试，还能做出一张好简历！ 后话机会总是留给有准备的人，共勉]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊单例]]></title>
    <url>%2F2017%2F06%2F04%2F%E8%81%8A%E8%81%8A%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[单例模式，相信很多开发者应该都很熟悉了，甚至都能够把写法轻而易举默写出来 ，但是对于资历尚浅的我来说，在做lintcode的一道要求实现单例的题目的时候，发现要完整的写出一个没有漏洞的单例，还是有点吃力的，看过很多优秀的博客，对单例的描述目前觉得好的主要有刘伟博士的设计模式系列以及wuchong的如何正确地写出单例模式。本文也是结合这两篇博客再融入自己的理解而成，会更多的关注实现单例的方法背后一些设计的思想以及细节。 循例介绍单例单例模式是什么顾名思义，单例模式，就是单个实例，在软件系统中的某个类只有唯一的一个实例，是独一无二的。在软件系统中，这个单一实例在创建成功之后，我们就不能再创建一个同类型的其他对象实例了，之后所有的操作都基于这个唯一实例。在设计模式中，单例模式被归类为对象创建型模式，为我们创建单一实例的软件设计提供了思路。 实现单例注意事项在单例模式中，关键点在于如何确保对象的唯一性： 回想下一般我们在创建对象的时候，一般不都是直接new一个对象出来吗？那也就是说，如果外部系统可以在想要的时候随时随地new出对象的话，那么这个类不就有可能同时存在多对象实例了吗，为了杜绝这种现象 第一步：把构造函数的访问权限改为private，禁止直接从外部new对象实例 那么问题来了，既然外部无法创建，那就只能靠内部创建并向外提供了，这就要求有一个维护该类实例的状态变量，始终唯一且时刻维护着该实例的状态，而且，为了保证封装性，我们把该变量设为private,只允许类内部访问。还有一个重点在于，必须把该变量设置为static的，为什么呢？如果是non-static的话，也就意味着，必须要先创建一个实例，才能进一步访问变量，然而并不允许外部创建实例，内部创建只会陷入恶性循环中，还会因产生用于访问的额外实例而破坏单一实例原则，也不优雅。因此， 第二步：定义某个类型的静态私有成员变量 现在，就剩下如何解决向外界提供该实例变量的问题了。我们可以专门写一个返回该类型变量的方法，而且为了能够保证外界直接访问，必须设置为公有静态的。该方法负责返回一直保存着的唯一实例，如果为null，则创建一个实例。所以， 第三步：增加获取唯一实例的公有静态方法 好了，基于以上几个步骤，我们可以写出最简单的单例了123456789101112class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance==null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 所以综合一下，单例模式确保对象唯一性其实也就三个要点：类中只能有唯一一个实例(禁止外部new、私有静态成员变量维护单一实例)；必须自行创建这个实例(校验单一实例是否为空)；自行向外部系统提供该实例(公有静态方法供外界访问) 如何正确实现单例仔细想想，上述单例的最简单实现真的就能够确保对象的唯一性了吗？在高并发情况下呢？由于系统中只有一个实例，getInstance()方法不可避免的会被并发调用。如果有一个线程A，调用了getInstance()方法，在new Singleton()的过程中，另外一个线程B也调用getInstance()方法，此时由于A还没有创建实例，B认为instance为空，结果又创建了一个instance对象，最后系统中就出现了两个实例，也就说明，上述最简单实现是线程不安全的，对整个系统是致命的。所以必须思考如何在多线程环境中仍然保证对象的唯一性 饿汉式VS懒汉式饿汉式认真想想，如果每个线程一开始拿到的就是创建好的唯一实例，不需要每个线程都进行非空判断并创建实例，那不就可以确保对象的唯一性了吗？因此就有了一种饿汉式单例的写法：123456789class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 在类加载的时候，静态变量instance就被初始化成单一实例了，此后每次调用getInstance()方法，得到的都是初始化时创建的实例，确保了对象的唯一性。虽然饿汉式单例实现简单，但是由于其一加载就初始化的特性，如果getInstance()始终没有被调用，则会浪费了很多创建对象时所消耗的系统资源，而且如果instance的创建依赖于某些配置文件和参数，必须先读取配置文件设置参数才能正确创建的话，那么饿汉式就无用武之地了 懒汉式懒汉式单例是一种延迟加载的实现，当需要的时候才会创建实例，正如最简单实现版本那样，但是又会有令人头疼的并发问题。回想一下我们在处理并发问题的时候，为了防止多线程同时访问，会用synchronized关键字加锁，于是单例实现可以写成： 123456789101112class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance==null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 不过synchronized关键字有时候是一个万恶的存在，因为在高并发环境下，每个线程等待的时间会越来越长，系统性能也会越来越低，当然并发编程领域发展到了今天对锁有更多更好的实现策略，如显式锁之类的，而使用synchronized关键字也是有优化的。这也就引出了接下来要讨论的双重检查锁。 双重检查锁我们会发现，其实并没有必要把所有线程都阻隔在判断之前，只有那些实例判断为空的线程才需要等待锁，判断不为空的其实可以直接返回单一实例，节省平均等待时间。因此，可以使用同步块来优化懒汉式加载，但是也需要注意一个问题，如果多个线程同时判断为空，进入同步块内等待锁，当其中一个线程成功创建对象实例后，另外那些等待线程并不知道对象实例已经创建，各自线程都会新建一个实例，这就破坏了单例原则，因此，在同步块内还需要增加一层非空判断，当其他线程获得锁之后，再次校验发现对象实例已经存在，就不会再创建实例，进而确保对象的唯一性。 1234567891011121314class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance==null)&#123; synchronized (Singleton.class)&#123; if(instance==null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 说实话，一开始我也以为上面的代码已经很完美的了，在这里特别感谢wuchong博客的一些提点，主要是JVM相关。以下引用下博客原话： 主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。1.给 instance 分配内存2.调用 Singleton 的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 解决方法也很简单，使用volatile关键字声明变量，即1private static volatile Singleton instance = null; 再一次感谢wuchong，原来 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 不过也需要注意，由于volatile禁止指令重排序优化，所以会导致系统运行效率降低，也需要慎用 静态内部类有没有方法可以既能实现延迟加载，又不需要担心线程安全问题呢？《Effective Java》上推荐静态内部类这种方法，也备受挺多人好评的。然而自己对内部类真的不熟悉，所以先通过一篇博客回顾下内部类相关知识点 这种使用静态内部类的技术也被成为IoDH——Initialization Demand Holder，单例实现如下：1234567891011class Singleton &#123; private Singleton()&#123;&#125; private static class SingletonHolder&#123; private static final Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 虽然静态内部类写在外部类里面，但是可以看做是两个相互独立的类。因此，当我们在加载Singleton时，并不会马上加载SingletonHolder,利用了静态初始化特性实现了instance的延迟加载。当第一次调用getInstance()时才加载内部类SinlgetonHolder，由于在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，并由Java虚拟机来保证其线程安全性，且确保该静态成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。乍一看，目前最好的单例实现方式应该就是静态内部类了吧。不过也要慎重，不是所有面向对象语言都像Java一样支持静态内部类的写法。 枚举还有一种枚举实现，不过由于很少使用枚举，所以不太熟悉，不过会用的话，写单例真的超级简单1234567891011//定义enum Singleton&#123; INSTANCE; void doSomething()&#123;&#125;&#125;//使用public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton.INSTANCE.doSomething(); &#125;&#125; 枚举单例是《Effective Java》作者推荐使用的方法，优点：不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。在《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 单例实现方式小结以上列举了几种单例的实现方式，涉及了一些线程安全、延迟加载、静态内部类、枚举等知识点，才发觉原本以为很简单的单例是这么的复杂。归结一下这些实现方式，都是在利用着不同的技术来确保对象的唯一性，也就是那三个要点。没有最好的方式，以后应该也会有更多更优雅的实现方式。就目前来说，能避免多线程同步问题尽量去避免，如果不要求延迟加载，饿汉方式也是不错的选择，静态内部类应该是最常见的方式了吧，如果涉及反序列化创建对象的话,枚举很优雅。 单例模式常见应用场景以及注意事项单例模式优缺点优点 在内存中只有一个对象，可以节省内存空间 避免频繁创建销毁对象，可以提高性能 避免对共享资源的多重占用，避免对同一资源文件同时操作造成文件状态不一致 可设置全局访问，优化和共享资源的访问 缺点 没有抽象层，难扩展 违背单一职责原则 应用场景由于单例模式具有的优点，因此可广泛用于节约系统资源、提升响应性能、保持共享资源状态一致等场景中，如：1.操作系统的文件系统，占用空间大且需保证文件状态一致2.数据库连接池和线程池等，避免频繁创建销毁数据库连接或线程3.任务管理器和回收站，保证共享资源状态一致4.网站计数器，计数器为共享资源5.应用程序的日志文件和配置文件的操作对象，共享资源保持状态一致 注意事项1.使用单例类提供的方法来获取单例对象，切记不要使用反射，因为反射会实例化一个新对象2.多线程使用单例操作共享资源，注意线程安全问题3.不要做断开单例类对象与类中静态引用的危险操作，否则单例对象会被JVM回收。更多阅读单例模式与垃圾收集 拓展——多例模式有了单例模式的一些实现思路，我们能否实现固定数量的多例呢？12345678910111213141516class MultiInstance&#123; //实例数量 private static int maxNum = 3; private static ArrayList&lt;MultiInstance&gt; instanceList = new Array&lt;MultiInstance&gt;(); //产生3个实例对象 static&#123; for(int i=0;i&lt;maxNum;i++)&#123; instanceList.add(new MultiInstance()); &#125; &#125; private MultiInstance()&#123;&#125; public static ArrayList&lt;MultiInstance&gt; getInstanceList()&#123; return instanceList; &#125;&#125; 上述多例实现属于饿汉式加载，可以参考数据库连接池或者线程池的实现了解更多 小结单例设计模式给我们创建单例对象提供了很好的思路，不过在实际开发环境中，我们不要把眼光局限在创建一个单例对象上，更要把目光放在单例对象的实际行为上。在web容器下，每个请求都会对应一个线程进行处理，而单例对象，例如数据库连接池等等，在高并发下如何表现出正确的行为也是值得思考的地方。正如刘伟博客的负载均衡器例子，负载均衡器功能实现思路的相关算法也需要好好研究。 Read More10 Singleton Pattern Interview Questions in Java设计模式系列如何正确地写出单例模式单例模式——极客学院Wiki单例模式应用场景]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[願我走出半生，归来仍是少年]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%84%BF%E6%88%91%E8%B5%B0%E5%87%BA%E5%8D%8A%E7%94%9F%EF%BC%8C%E5%BD%92%E6%9D%A5%E4%BB%8D%E6%98%AF%E5%B0%91%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[成长总是在漫不经意间，如今又晃过了一个六一儿童节，在1996-2017这21年的岁月中，自己也从一个不知天高地厚的小屁孩长大成一个开始为生活奔波的年轻人了。现在都还记得小学时的某一个六一儿童节活动，那时也不知道哪里来的自信，居然敢在全班面前唱《火力少年王》的片尾曲，对，就是那个yoyo球盛行时期的一首歌《蓝天之约》，至今都还记得收获的掌声和那块被我一口吃掉的杏仁饼。那时候的我，面对这些小确幸，说不出的满足。虽然现在对儿童节这种节日早已没有了任何的期待，不过作为开博首记，必须来篇仪式感满满的博客，以纪念走过21个年头。 願平安无事地度过青春期，但别平安无事地度过青春和大多数的中国孩纸一样，我在高考结束之前的生活主旋律，基本都是读书、做作业和考试，和一些多动的“坏孩纸”不同，自从上了初中，我就有了一颗想当学霸的心了，而且那时候极度厌恶那些整天吊儿郎当，无所事事，天天捉弄周围同学的人，完全不想和只知道打架的人为伍。也不是有多大的觉悟，我小学的时候也经常调皮捣蛋，整天跑出去各种浪，直到某次对家里做出一些伤害，发生了一些小插曲之后，从此就痛改前非，决定不再让家里人操心了。于是乎，一个亲戚中、小区里、班上都公认的学霸从此诞生，这时候最开心的当然是父母了，毕竟孩纸厉害，自己也就有面子嘛。每逢亲戚过年过节、学校开家长会、小区散步等等，只要是爸妈可以聊到关于我的时候，感觉神情就各种骄傲，仿佛在炫耀着有这么一个争气的儿子。而我自然也开心啊，毕竟家里已经不再需要为我担心了。不过，自从高二进了一中的重点班之后，就发现，这世界原来还有更多的学霸存在，他们可以花更少的时间，取得更好的成绩，而且还可以各种浪。毫无意外，之前还可以稳稳坐在前三宝座的我，在重点班中我已经稳稳地躺在班级倒数的行列中了，感觉虽然很努力的追赶，但是却始终赶不上聪明人的脚步，郁郁不得志的时候，人总会相对失落，成绩也不上不下的，一开始还有点压抑，后来慢慢习惯了之后，感觉也没什么大不了的。而且这个时候，其实已经没有之前那么看重成绩了，反而开始逐渐对未来有了更多的憧憬，痴迷于各种高科技，幻想着可以像乔布斯那样——一直相信活着就是为了改变世界，并以此作为高中毕业之后的人生目标。现在回想起来仍然觉得当初的自己好傻逼，不过人呐，年轻的时候谁没有几个傻逼的梦想。平平淡淡，没有搞出什么大新闻，青春期也就这样平安无事地过去了，但是现在想想又有点不甘心，感觉自己的青春就被狗吃了那样，除了学习之外一无所有。最近特别迷几位美国的翻唱歌手，ChrissyCostanza、KurtHugoSchneider、SamTsui、MadilynBailey等等,看着他们的一部部才华横溢的MV，不由得感叹，这才叫青春啊，可以做着自己真正喜欢的事情，每天都开开心心，自由随性无拘无束，真好，这才是我觉得青春该有的样子啊。有时候啊，总是会不由自主地羡慕着别人的生活，但是想多了，也就这样了，虽然家里给不了我很优厚的成长环境，但是起码在这些岁月中，我从来不用担心温饱，能够接受良好教育，能平安无事的长大成人啊，说不准还会有人羡慕我哩！人都有一种病，一种明明吃着自己碗里的，心里却时刻惦记着别人碗里的病。不过也好，证明了自己不安于现状，拥有改变自己生活状态的欲望。争气点，努力活出想要的样子。 願往后的青春都能波涛汹涌，活出想要的样子，品味人生百态~ 願纵使迷茫，也相信所做一切皆有意义如果人生有几道分水岭的话，那么高考无疑是我人生中的第一道，虽然小时候想上清华北大的愿望并没有实现（差距还有点大），不过也考上了省里的一本学校，家里还挺高兴的，毕竟在他们眼里，我已经挺有出息了，但是对我而言，还是不那么如意，想考中大华工没考上也没办法，既来之则安之吧，坚决不复读，于是就一个人拖着行囊，来到学校报道，大学生活就这样拉开了帷幕。幸运地是，在大学期间也不知道哪里来的福分，受到了挺多师兄师姐的关照，进了社团，下了乡，管理校友会，组建创业团队，加入初创公司等等，忙着能赚些许生活费的小门路，虽然都是在校园里和朋友的小打小闹，但是觉得比起很多同龄人，大学经历已经丰富很多了，即使自己的表现不是非常地突出，甚至很多东西都没有经过大脑，但是也毫不妨碍我自认为活出想要的样子，每一天的生活都很充实、满足。直到了大二下学期，也记不起为什么，慢慢开始思索着将来究竟要做什么的问题，总感觉没有点真才实学以后毕业了就是混吃等死的样子，而且感觉自己的技术宅改变世界的梦想已经遥不可及了，没错，大一大二的生活轨迹遗憾之一就是没有好好的学习。而且自己还是有点自知之明的，深知自己也不怎么适合做市场方面的工作，而且回想起自己当初这个选学校选这个专业的时候，就是为了在大学里学技术啊，没想到不小心就走偏了，果然还是耐不住寂寞。和很多人一样，我也觉得我上大学之后报错了专业，不过是不够贴近自己想要的技术，应该选计算机的，却选了信息工程，天真的以为软硬都会比只会打码的计算机厉害，naive。也是挺幸运的，在想要转型的时候，刚好有机会加入学院的实验室团队，在里面和其他人一起学技术，于是在大三期间，几乎就赖在了实验室，就差在里面打地铺过夜了。讲道理，大二大三之际才开始认真学，而且还是自学为主确实有点吃力，各种计算机基础课，比如数据结构与算法，操作系统，计算机网络等，本专业的课程基本没有，几乎都要重新看书，还要学Java，这么多年了，Java的生态体系又那么的庞大,反正越学越觉得水深，越学越觉得自己好菜，学习了很多但是又感觉什么都没有学到，转眼就到了金三银四暑期实习生招聘，也就是刚过去的一段时间，好多朋友都找到了不错的实习，而自己还是颗粒无收，大公司全跪，小公司多数简历石沉大海，一方面可能因为是自己技术水平不够，学习不够针对，另一方面就是面试表现不好，当然还有更多自己没有想出来的原因。说实话，还真的跑上过天台一个人独自看着月亮落泪，抱怨着命运不公，后悔着自己大一大二浪费了好多时间诸如此类的。可能这就是生活吧，想要的，不一定总拿得到；但是，不努力争取，就一定得不到！接下来还要继续努力，相信美好的事情即将发生。有时也挺佩服自己的，虽然也有迷茫期，但是也能大致确定努力的方向，也一直自己做出决定。然而还有很多人，其实都不知道自己真正想要的是什么。迷茫是正常的，谁的青春不迷茫？但要时刻相信，自己现在所做的一切，虽然目前看上去没有什么实际的价值，但是极有可能就会在将来的某个时刻回报自己。前几天在简书上收到一封简信，是某个书院的主编因为对我去年写的一篇关于《乌合之众》的解读感兴趣，想邀请我加入他们的一个拆书的项目。《拜读乌合之众——我所理解的大众心理》，其实只是一篇业余的解读，当时刚好看了《浪潮》这部电影，对大众心理学感兴趣，于是花了一周的时间研读整理出来的一篇心得，随手发表到了简书上，没想到阅读量就过1300了，而且在几天之内多出了很多粉丝，得到他人肯定的感觉真的很好，付出原来真的是有回报的，而且惊喜总会悄然而至，包括时隔一年的邀请。 願纵使碰壁无数，迷茫无助，也要相信美好的事情即将发生，梦想还是要有的，万一实现了呢？ 願我走出半生，归来仍是少年谈及梦想，在充分意识到理想与现实的差距之后，貌似现在已经不能很清楚的描述出来了，慢慢地，开始向现实妥协。可能是因为现在的生活，已经不能像儿时那样无忧无虑了吧，年纪越长越大，顾虑越来越多，闹人的事接踵而至，生活也面临着各种压力，突然觉得，那些年少时光，真的回不去了。有时自己会想一些奇奇怪怪的东西，例如人活着的意义是什么，难得在人世间走一遭，就是为了每天吃喝拉撒睡，学习工作无限循环吗？思索了自己为什么那么想回到儿时，大抵是一块糖果或一次掌声就已经可以开心大半天的那种简单吧。虽然现在已经很难回归到那种纯粹，但是自从翻出看完《遗愿清单》后心血来潮给自己写的一份清单之后，感觉其实也没那么难了，毕竟清单里的事情，都是最想做的事情。转念一想，其实现在在做的，不也是为了实现清单里的目标在做准备吗？当清单里的目标全部勾完的那一刻，一定可以像儿时那样，开心大半天，最后感动自己吧，哈哈哈。 願我此生即使伤痕累累，归来仍是少年般纯真]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
